
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>던전 게임 - React + Phaser</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- React 18 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel (브라우저에서 JSX 변환용) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #000;
        overflow: hidden;
      }
      #root {
        width: 100%;
        height: 100%;
      }
      button {
        font-family: inherit;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useRef, useState } = React;

      // --- 유틸 함수 ---
      function clamp(v, min, max) {
        if (v < min) return min;
        if (v > max) return max;
        return v;
      }
      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      function choice(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      // --- 통로 씬 ---
      class DungeonCorridorScene extends Phaser.Scene {
        constructor() {
          super({ key: "DungeonCorridorScene" });
        }

        init(data) {
          const seg = (data && data.segmentIndex) || 1;
          this.segmentIndex = seg;

          let maxSeg = this.registry.get("maxSegments");
          if (!maxSeg) {
            maxSeg = randInt(5, 9);
            this.registry.set("maxSegments", maxSeg);
          }
          this.maxSegments = maxSeg;

          let stressLike = this.registry.get("stressLike");
          if (stressLike === undefined || stressLike === null) {
            stressLike = 0;
            this.registry.set("stressLike", stressLike);
          }
          this.stressLike = stressLike;

          this.initialPlayerX = 200;
        }

        preload() {}

        create() {
          const width = this.game.config.width;
          const height = this.game.config.height;
          const floorY = height - 120;

          const worldWidth = 2200;
          this.cameras.main.setBounds(0, 0, worldWidth, height);
          this.physics.world.setBounds(0, 0, worldWidth, height);

          // 배경
          this.add.rectangle(
            worldWidth / 2,
            height / 2,
            worldWidth,
            height,
            0x050608
          );
          this.add.rectangle(
            worldWidth / 2,
            height - 80,
            worldWidth,
            160,
            0x181818
          );
          this.add.rectangle(
            worldWidth / 2,
            height - 200,
            worldWidth,
            120,
            0x111111,
            0.5
          );

          for (let x = 200; x < worldWidth; x += 320) {
            this.add.rectangle(x, floorY - 40, 10, 80, 0x303030);
          }

          // 방으로 가는 문
          this.doorX = 1600;
          this.add.rectangle(this.doorX, floorY - 40, 46, 100, 0x444488);
          this.add.rectangle(this.doorX, floorY - 100, 86, 26, 0x333344);
          this.add
            .text(this.doorX, floorY - 130, "방으로 들어가는 문", {
              fontSize: "12px",
              fill: "#ffffff",
            })
            .setOrigin(0.5);

          // 통로 오브젝트들
          this.objects = [];
          this.objectSprites = {};

          const corridorObjectsDefs = [
            { type: "chest", label: "통로의 상자" },
            { type: "curio", label: "벽에 걸린 부적" },
            { type: "none", label: "" },
          ];

          for (let i = 0; i < 2; i++) {
            const def = choice(corridorObjectsDefs);
            if (def.type === "none") continue;
            const objX = randInt(400, 1300);
            const id = `corr_obj_${i}`;
            const obj = {
              id,
              type: def.type,
              x: objX,
              label: def.label,
              used: false,
            };
            this.objects.push(obj);
          }

          // 이벤트 느낌표(!) 확률 25%
          if (Math.random() < 0.25) {
            const exId = "corr_event_1";
            const exX = randInt(600, 1400);
            this.objects.push({
              id: exId,
              type: "event",
              x: exX,
              label: "강한 기운의 흔적",
              used: false,
            });
          }

          this.objects.forEach((obj) => {
            let sprite = null;
            if (obj.type === "chest") {
              sprite = this.add.rectangle(obj.x, floorY - 10, 60, 40, 0x996633);
            } else if (obj.type === "curio") {
              sprite = this.add.circle(obj.x, floorY - 30, 20, 0x5577aa);
            } else if (obj.type === "event") {
              sprite = this.add
                .text(obj.x, floorY - 80, "!", {
                  fontSize: "40px",
                  fill: "#ffdd33",
                })
                .setOrigin(0.5);
            }
            this.objectSprites[obj.id] = sprite;
          });

          // 플레이어
          this.player = this.add.rectangle(
            this.initialPlayerX,
            height - 140,
            28,
            64,
            0xddddff
          );
          this.physics.add.existing(this.player);
          this.player.body.setCollideWorldBounds(true);

          this.cameras.main.startFollow(this.player, true, 0.09, 0.09);

          // 입력
          this.speed = 220;
          this.keys = this.input.keyboard.addKeys("W,A,S,D,E");

          // UI
          this.infoText = this.add
            .text(
              16,
              16,
              `통로 ${this.segmentIndex}/${this.maxSegments} | WASD 이동 | E: 문/오브젝트 상호작용`,
              { fontSize: "14px", fill: "#ffffff" }
            )
            .setScrollFactor(0);

          this.interactionText = this.add
            .text(16, 40, "", {
              fontSize: "14px",
              fill: "#88ffdd",
            })
            .setScrollFactor(0);

          this.messageText = this.add
            .text(16, 64, "", {
              fontSize: "14px",
              fill: "#ffdd88",
              wordWrap: { width: width - 32 },
            })
            .setScrollFactor(0);

          this.stressText = this.add
            .text(16, 110, "", {
              fontSize: "13px",
              fill: "#ff8888",
            })
            .setScrollFactor(0);
          this.updateStressText();

          this.currentInteractable = null;
          this.playerLocked = false;

          this.keys.E.on("down", () => {
            if (!this.currentInteractable) return;
            if (this.currentInteractable.kind === "door") {
              this.enterRoom();
            } else if (this.currentInteractable.kind === "object") {
              this.handleObjectInteraction(this.currentInteractable.data);
            }
          });
        }

        update() {
          const body = this.player.body;

          if (!this.playerLocked) {
            body.setVelocity(0);

            if (this.keys.A.isDown) {
              body.setVelocityX(-this.speed);
            } else if (this.keys.D.isDown) {
              body.setVelocityX(this.speed);
            }

            if (this.keys.W.isDown) {
              body.setVelocityY(-this.speed / 3);
            } else if (this.keys.S.isDown) {
              body.setVelocityY(this.speed / 3);
            }
          } else {
            body.setVelocity(0);
          }

          const minY = this.game.config.height - 220;
          const maxY = this.game.config.height - 100;
          this.player.y = clamp(this.player.y, minY, maxY);

          let nearest = null;
          let nearestDist = 9999;
          const range = 80;

          const doorDist = Math.abs(this.player.x - this.doorX);
          if (doorDist < range) {
            nearest = { kind: "door", data: null };
            nearestDist = doorDist;
          }

          for (let i = 0; i < this.objects.length; i++) {
            const obj = this.objects[i];
            if (obj.used && obj.type !== "event") continue;
            const dist = Math.abs(this.player.x - obj.x);
            if (dist < range && dist < nearestDist) {
              nearest = { kind: "object", data: obj };
              nearestDist = dist;
            }
          }

          this.currentInteractable = nearest;

          if (!nearest) {
            this.interactionText.setText("");
          } else if (nearest.kind === "door") {
            this.interactionText.setText("E: 방 안으로 들어간다");
          } else if (nearest.kind === "object") {
            const tag = nearest.data.type === "event" ? "이벤트" : "조사";
            this.interactionText.setText(`E: [${nearest.data.label}] ${tag}`);
          }
        }

        updateStressText() {
          const v = clamp(this.stressLike, 0, 100);
          this.stressLike = v;
          this.registry.set("stressLike", v);
          this.stressText.setText(`정신 압박: ${v} / 100`);
        }

        handleObjectInteraction(obj) {
          let msg = "";

          if (obj.type === "chest") {
            if (obj.used) {
              msg = "이미 털린 상자다.";
            } else {
              const healStress = randInt(1, 3);
              this.stressLike = Math.max(0, this.stressLike - healStress);
              msg =
                "통로의 상자를 열어 약간의 전리품을 얻었다. (예: 골드/아이템)\n" +
                `약간의 안도감이 들어 정신 압박이 ${healStress}만큼 줄어든 것 같다.`;
              obj.used = true;
              const spriteChest = this.objectSprites[obj.id];
              if (spriteChest && spriteChest.setFillStyle) {
                spriteChest.setFillStyle(0x555522);
              }
            }
          } else if (obj.type === "curio") {
            if (obj.used) {
              msg = "이미 조사한 부적이다. 여전히 음침하다.";
            } else {
              const bad = Math.random() < 0.5;
              if (bad) {
                const inc = randInt(2, 5);
                this.stressLike = Math.min(100, this.stressLike + inc);
                msg =
                  "부적에서 불길한 기운이 새어 나온다. 머리가 지끈거리고 손이 떨린다.\n" +
                  `정신 압박이 ${inc}만큼 상승했다.`;
              } else {
                const dec = randInt(1, 4);
                this.stressLike = Math.max(0, this.stressLike - dec);
                msg =
                  "부적을 자세히 살펴보았다. 묘하게 안심되는 기운이 느껴진다.\n" +
                  `정신 압박이 ${dec}만큼 감소했다.`;
              }
              obj.used = true;
              const spriteCurio = this.objectSprites[obj.id];
              if (spriteCurio && spriteCurio.setFillStyle) {
                spriteCurio.setFillStyle(0x88aadd);
              }
            }
          } else if (obj.type === "event") {
            const incEv = randInt(3, 6);
            this.stressLike = Math.min(100, this.stressLike + incEv);
            msg =
              "강한 기운이 모여 있는 지점이다. 눈에 보이지 않는 무언가가 당신을 응시한다.\n" +
              "여기는 언젠가 전투나 대형 이벤트의 무대가 될 것이다.\n" +
              `정신 압박이 ${incEv}만큼 상승했다.`;
            const spriteEv = this.objectSprites[obj.id];
            if (spriteEv && spriteEv.setStyle) {
              spriteEv.setStyle({ fill: "#ffe866" });
            }
          }

          this.updateStressText();
          this.messageText.setText(msg);
        }

        enterRoom() {
          this.scene.start("DungeonRoomScene", {
            segmentIndex: this.segmentIndex,
          });
        }
      }

      // --- 방 씬 ---
      class DungeonRoomScene extends Phaser.Scene {
        constructor() {
          super({ key: "DungeonRoomScene" });
        }

        init(data) {
          this.segmentIndex = (data && data.segmentIndex) || 1;
          const maxSeg = this.registry.get("maxSegments") || 7;
          this.maxSegments = maxSeg;
          this.isLastRoom = this.segmentIndex >= this.maxSegments;

          let stressLike = this.registry.get("stressLike");
          if (stressLike === undefined || stressLike === null) {
            stressLike = 0;
            this.registry.set("stressLike", stressLike);
          }
          this.stressLike = stressLike;
        }

        preload() {}

        create() {
          const width = this.game.config.width;
          const height = this.game.config.height;
          const floorY = height - 120;

          this.cameras.main.setBounds(0, 0, width, height);
          this.physics.world.setBounds(0, 0, width, height);

          this.add.rectangle(width / 2, height / 2, width, height, 0x070409);
          this.add.rectangle(width / 2, height - 80, width, 160, 0x1b1418);
          this.add.rectangle(width / 2, 80, width - 160, 40, 0x222222);
          this.add.rectangle(80, height / 2, 40, height - 120, 0x222222);
          this.add.rectangle(width - 80, height / 2, 40, height - 120, 0x222222);

          this.add
            .text(width / 2, 40, `구간 ${this.segmentIndex}/${this.maxSegments} - 방`, {
              fontSize: "18px",
              fill: "#ffffff",
            })
            .setOrigin(0.5);

          const ROOM_TYPES = [
            {
              type: "treasure",
              label: "보물 방",
              patterns: [
                { dx: -140, kind: "chest", label: "잠긴 상자" },
                { dx: -20, kind: "curio", label: "빛나는 제단" },
              ],
            },
            {
              type: "trap",
              label: "함정 방",
              patterns: [
                { dx: -60, kind: "trap", label: "바닥 함정" },
                { dx: 80, kind: "curio", label: "수상한 조각상" },
              ],
            },
            {
              type: "curio",
              label: "유물 방",
              patterns: [
                { dx: -80, kind: "curio", label: "기묘한 석상" },
                { dx: 60, kind: "curio", label: "낡은 제단" },
              ],
            },
            {
              type: "empty",
              label: "버려진 방",
              patterns: [{ dx: 0, kind: "curio", label: "버려진 등불" }],
            },
          ];

          const tpl = choice(ROOM_TYPES);
          this.add
            .text(width / 2, 70, tpl.label, {
              fontSize: "14px",
              fill: "#bbbbff",
            })
            .setOrigin(0.5);

          this.exitX = width - 140;
          const exitLabel = this.isLastRoom ? "던전 출구" : "다음 통로로";
          const exitColor = this.isLastRoom ? 0x77bb77 : 0x448844;
          this.add.rectangle(this.exitX, floorY - 40, 40, 90, exitColor);
          this.add
            .text(this.exitX, floorY - 90, exitLabel, {
              fontSize: "12px",
              fill: "#ffffff",
            })
            .setOrigin(0.5);

          this.objects = [];
          this.objectSprites = {};

          tpl.patterns.forEach((pat, index) => {
            const id = `room_obj_${index}`;
            const x = width / 2 + pat.dx;
            const obj = {
              id,
              type: pat.kind,
              x,
              label: pat.label,
              used: false,
            };
            this.objects.push(obj);
          });

          if (Math.random() < 0.25) {
            const exId = "room_event_1";
            const exX = width / 2;
            this.objects.push({
              id: exId,
              type: "event",
              x: exX,
              label: "불길한 전조",
              used: false,
            });
          }

          this.objects.forEach((obj) => {
            let sprite = null;
            if (obj.type === "chest") {
              sprite = this.add.rectangle(obj.x, floorY - 10, 60, 40, 0x996633);
            } else if (obj.type === "curio") {
              sprite = this.add.circle(obj.x, floorY - 30, 22, 0x5577aa);
            } else if (obj.type === "trap") {
              sprite = this.add.rectangle(obj.x, floorY, 80, 12, 0xaa3333);
            } else if (obj.type === "event") {
              sprite = this.add
                .text(obj.x, floorY - 90, "!", {
                  fontSize: "40px",
                  fill: "#ffdd33",
                })
                .setOrigin(0.5);
            }
            this.objectSprites[obj.id] = sprite;
          });

          this.player = this.add.rectangle(width / 2, floorY - 40, 28, 64, 0xddddff);
          this.physics.add.existing(this.player);
          this.player.body.setCollideWorldBounds(true);

          this.speed = 200;
          this.keys = this.input.keyboard.addKeys("W,A,S,D,E");

          this.infoText = this.add
            .text(
              16,
              16,
              `방 ${this.segmentIndex}/${this.maxSegments} | WASD 이동 | E: 오브젝트/출구 상호작용`,
              { fontSize: "14px", fill: "#ffffff" }
            )
            .setScrollFactor(0);

          this.interactionText = this.add
            .text(16, 40, "", {
              fontSize: "14px",
              fill: "#88ffdd",
            })
            .setScrollFactor(0);

          this.messageText = this.add
            .text(16, 64, "", {
              fontSize: "14px",
              fill: "#ffdd88",
              wordWrap: { width: width - 32 },
            })
            .setScrollFactor(0);

          this.stressText = this.add
            .text(16, 110, "", {
              fontSize: "13px",
              fill: "#ff8888",
            })
            .setScrollFactor(0);
          this.updateStressText();

          this.currentInteractable = null;
          this.playerLocked = false;
          this.dungeonFinished = false;

          this.keys.E.on("down", () => {
            if (!this.currentInteractable) return;
            if (this.currentInteractable.kind === "exit") {
              if (this.isLastRoom) {
                this.finishDungeon();
              } else {
                this.goNextCorridor();
              }
            } else if (this.currentInteractable.kind === "object") {
              this.handleObjectInteraction(this.currentInteractable.data);
            }
          });
        }

        update() {
          const body = this.player.body;

          if (!this.playerLocked) {
            body.setVelocity(0);

            if (this.keys.A.isDown) {
              body.setVelocityX(-this.speed);
            } else if (this.keys.D.isDown) {
              body.setVelocityX(this.speed);
            }

            if (this.keys.W.isDown) {
              body.setVelocityY(-this.speed / 3);
            } else if (this.keys.S.isDown) {
              body.setVelocityY(this.speed / 3);
            }
          } else {
            body.setVelocity(0);
          }

          const minY = this.game.config.height - 220;
          const maxY = this.game.config.height - 100;
          this.player.y = clamp(this.player.y, minY, maxY);

          let nearest = null;
          let nearestDist = 9999;
          const range = 80;

          const exitDist = Math.abs(this.player.x - this.exitX);
          if (exitDist < range) {
            nearest = { kind: "exit", data: null };
            nearestDist = exitDist;
          }

          for (let i = 0; i < this.objects.length; i++) {
            const obj = this.objects[i];
            if (obj.used && obj.type !== "event") continue;
            const dist = Math.abs(this.player.x - obj.x);
            if (dist < range && dist < nearestDist) {
              nearest = { kind: "object", data: obj };
              nearestDist = dist;
            }
          }

          this.currentInteractable = nearest;

          if (!nearest) {
            this.interactionText.setText("");
          } else if (nearest.kind === "exit") {
            const label = this.isLastRoom
              ? "E: 던전 출구로 나간다"
              : "E: 다음 통로로 나아간다";
            this.interactionText.setText(label);
          } else if (nearest.kind === "object") {
            const tag = nearest.data.type === "event" ? "이벤트" : "조사";
            this.interactionText.setText(`E: [${nearest.data.label}] ${tag}`);
          }
        }

        updateStressText() {
          const v = clamp(this.stressLike, 0, 100);
          this.stressLike = v;
          this.registry.set("stressLike", v);
          this.stressText.setText(`정신 압박: ${v} / 100`);
        }

        handleObjectInteraction(obj) {
          if (obj.type !== "event" && obj.used) return;

          let msg = "";

          if (obj.type === "chest") {
            const dec = randInt(1, 4);
            this.stressLike = Math.max(0, this.stressLike - dec);
            msg =
              "잠긴 상자를 열었다. 안에는 수상한 전리품이 들어 있다.\n" +
              `전리품을 얻으며 잠시 웃음이 새어 나온다. 정신 압박이 ${dec}만큼 감소했다.`;
            obj.used = true;
            const spriteChest = this.objectSprites[obj.id];
            if (spriteChest && spriteChest.setFillStyle) {
              spriteChest.setFillStyle(0x555522);
            }
          } else if (obj.type === "curio") {
            const bad = Math.random() < 0.5;
            if (bad) {
              const inc = randInt(2, 6);
              this.stressLike = Math.min(100, this.stressLike + inc);
              msg =
                "유물에 손을 대는 순간, 끔찍한 환상이 스쳐 지나간다.\n" +
                `정신 압박이 ${inc}만큼 상승했다.`;
            } else {
              const dec2 = randInt(1, 5);
              this.stressLike = Math.max(0, this.stressLike - dec2);
              msg =
                "유물에서 은은한 빛이 새어 나온다. 어쩐지 마음이 조금 가벼워진다.\n" +
                `정신 압박이 ${dec2}만큼 감소했다.`;
            }
            obj.used = true;
            const spriteCurio = this.objectSprites[obj.id];
            if (spriteCurio && spriteCurio.setFillStyle) {
              spriteCurio.setFillStyle(0x88aadd);
            }
          } else if (obj.type === "trap") {
            const incTrap = randInt(3, 7);
            this.stressLike = Math.min(100, this.stressLike + incTrap);
            msg =
              "함정이 발동했다! 상처가 깊게 남고, 공포가 머릿속을 파고든다.\n" +
              `정신 압박이 ${incTrap}만큼 상승했다.`;
            obj.used = true;
            const spriteTrap = this.objectSprites[obj.id];
            if (spriteTrap && spriteTrap.setFillStyle) {
              spriteTrap.setFillStyle(0x333333);
            }
            this.tweens.add({
              targets: this.player,
              alpha: 0.2,
              yoyo: true,
              repeat: 3,
              duration: 80,
            });
          } else if (obj.type === "event") {
            const incEv = randInt(4, 8);
            this.stressLike = Math.min(100, this.stressLike + incEv);
            msg =
              "방 한가운데, 강렬한 기운이 소용돌이친다. 보이지 않는 시선이 심장을 겨눈다.\n" +
              "이 지점은 나중에 전투나 대형 이벤트가 일어나는 트리거가 될 것이다.\n" +
              `정신 압박이 ${incEv}만큼 상승했다.`;
            const spriteEv = this.objectSprites[obj.id];
            if (spriteEv && spriteEv.setStyle) {
              spriteEv.setStyle({ fill: "#ffe866" });
            }
          }

          this.updateStressText();
          this.messageText.setText(msg);
        }

        goNextCorridor() {
          if (this.dungeonFinished) return;
          this.scene.start("DungeonCorridorScene", {
            segmentIndex: this.segmentIndex + 1,
          });
        }

        finishDungeon() {
          if (this.dungeonFinished) return;
          this.dungeonFinished = true;

          this.playerLocked = true;
          this.messageText.setText(
            "던전의 출구에 도달했다.\n" +
              "이제 남은 것은, 이곳에서 얻은 것들과 잃은 것을 정산하는 일뿐이다.\n" +
              "(여기서 클리어 결과 화면/보상/전투 로그 등으로 넘어갈 예정)"
          );
        }
      }

      // --- Phaser 설정 ---
      const createPhaserConfig = (parent) => ({
        type: Phaser.AUTO,
        width: 960,
        height: 540,
        backgroundColor: "#000000",
        physics: {
          default: "arcade",
          arcade: {
            gravity: { y: 0 },
            debug: false,
          },
        },
        scene: [DungeonCorridorScene, DungeonRoomScene],
        parent,
      });

      // --- 캐릭터 기초 스탯 (속도 통합 30 / 힘 0 / 에너지 6 / 체력 30) ---
      const baseStats = {
        hp: { current: 30, max: 30 },
        energy: { current: 6, max: 6 },
        speed: 30,
        power: 0,
      };

      // --- 카드 덱 (확장 가능) ---
      const initialDeck = [
        {
          slot: 1,
          name: "Quick Slash",
          type: "공격",
          speed: 3,
          ap: 1,
          desc: "빠른 근접 공격, 선제용",
        },
        {
          slot: 2,
          name: "Guard Stance",
          type: "방어",
          speed: 6,
          ap: 1,
          desc: "기본 방어자세, 방어력 확보",
        },
        {
          slot: 3,
          name: "Parry",
          type: "반격",
          speed: 2,
          ap: 1,
          desc: "공격을 흘려 반격",
        },
        {
          slot: 4,
          name: "Focus Heal",
          type: "회복",
          speed: 10,
          ap: 2,
          desc: "집중 치유, 체력 회복",
        },
        {
          slot: 5,
          name: "Feint Strike",
          type: "공격",
          speed: 4,
          ap: 1,
          desc: "하이리스크 하이리턴 공격",
        },
        {
          slot: 6,
          name: "Adrenaline Surge",
          type: "버프",
          speed: 4,
          ap: 2,
          desc: "속도/행동력 버프",
        },
      ];

      // --- React 스타일 ---
      const rootStyle = {
        width: "100vw",
        height: "100vh",
        display: "flex",
        alignItems: "stretch",
        justifyContent: "center",
        background: "#111",
        color: "#fff",
        fontFamily:
          'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
        position: "relative",
      };

      const gameContainerStyle = {
        flex: 1,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      };

      const uiPanelStyle = {
        width: 320,
        padding: 12,
        boxSizing: "border-box",
        borderLeft: "1px solid #333",
        background: "radial-gradient(circle at top left, #222 0, #111 60%)",
        fontSize: 13,
        lineHeight: 1.4,
      };

      const codeStyle = {
        background: "#222",
        padding: "2px 4px",
        borderRadius: 3,
      };

      const charOverlayStyle = {
        position: "absolute",
        inset: 0,
        background: "rgba(0,0,0,0.6)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 10,
      };

      const charWindowStyle = {
        width: 560,
        maxHeight: "82vh",
        background: "#151521",
        borderRadius: 12,
        border: "1px solid #3a3a60",
        boxShadow: "0 14px 40px rgba(0,0,0,0.8)",
        padding: 16,
        boxSizing: "border-box",
        display: "flex",
        flexDirection: "column",
      };

      const statRowStyle = {
        display: "flex",
        justifyContent: "space-between",
        marginBottom: 4,
        fontSize: 13,
      };

      const statLabelStyle = { opacity: 0.8 };
      const statValueStyle = { fontWeight: 600 };

      // 기본 카드 박스 스타일
      const cardRowBaseStyle = {
        borderRadius: 6,
        padding: "4px 6px",
        marginBottom: 4,
        background: "#1b1b24",
        border: "1px solid #31314a",
        transition: "box-shadow 0.15s ease, border-color 0.15s ease, background 0.15s ease",
      };

      const downloadButtonStyle = {
        marginTop: 6,
        padding: "4px 8px",
        fontSize: 11,
        borderRadius: 6,
        border: "1px solid #3a3a60",
        background: "#181820",
        color: "#eee",
        cursor: "pointer",
      };

      // --- JSX 파일 내용 (캐릭터 창 / 특기 선택 UI만 포함하는 버전) ---
      const jsxFileContent = `import React, { useState } from "react";

const baseStats = {
  hp: { current: 30, max: 30 },
  energy: { current: 6, max: 6 },
  speed: 30,
  power: 0,
};

const initialDeck = [
  { slot: 1, name: "Quick Slash", type: "공격", speed: 3, ap: 1, desc: "빠른 근접 공격, 선제용" },
  { slot: 2, name: "Guard Stance", type: "방어", speed: 6, ap: 1, desc: "기본 방어자세, 방어력 확보" },
  { slot: 3, name: "Parry", type: "반격", speed: 2, ap: 1, desc: "공격을 흘려 반격" },
  { slot: 4, name: "Focus Heal", type: "회복", speed: 10, ap: 2, desc: "집중 치유, 체력 회복" },
  { slot: 5, name: "Feint Strike", type: "공격", speed: 4, ap: 1, desc: "하이리스크 하이리턴 공격" },
  { slot: 6, name: "Adrenaline Surge", type: "버프", speed: 4, ap: 2, desc: "속도/행동력 버프" },
];

const cardRowBaseStyle = {
  borderRadius: 6,
  padding: "4px 6px",
  marginBottom: 4,
  background: "#1b1b24",
  border: "1px solid #31314a",
  transition: "box-shadow 0.15s ease, border-color 0.15s ease, background 0.15s ease",
};

const statRowStyle = {
  display: "flex",
  justifyContent: "space-between",
  marginBottom: 4,
  fontSize: 13,
};

const statLabelStyle = { opacity: 0.8 };
const statValueStyle = { fontWeight: 600 };

function DungeonGameCharacterBuild() {
  const [specialMode, setSpecialMode] = useState("main");
  const [mainSpecials, setMainSpecials] = useState([]);
  const [subSpecials, setSubSpecials] = useState([]);

  const getCardStyle = (slot) => {
    const isMain = mainSpecials.includes(slot);
    const isSub = subSpecials.includes(slot);

    let borderColor = "#31314a";
    let boxShadow = "none";
    let background = cardRowBaseStyle.background;

    if (isMain) {
      borderColor = "#f5d76e";
      boxShadow = "0 0 8px rgba(245,215,110,0.9)";
      background = "#2a2615";
    } else if (isSub) {
      borderColor = "#4ea3ff";
      boxShadow = "0 0 8px rgba(78,163,255,0.9)";
      background = "#172538";
    }

    return {
      ...cardRowBaseStyle,
      border: "1px solid " + borderColor,
      boxShadow,
      background,
      cursor: "pointer",
    };
  };

  const handleCardClick = (slot) => {
    if (specialMode === "main") {
      setMainSpecials((prev) => {
        if (prev.includes(slot)) {
          return prev.filter((s) => s !== slot);
        }
        if (prev.length >= 3) return prev;
        setSubSpecials((prevSub) => prevSub.filter((s) => s !== slot));
        return [...prev, slot];
      });
    } else {
      setSubSpecials((prev) => {
        if (prev.includes(slot)) {
          return prev.filter((s) => s !== slot);
        }
        if (prev.length >= 5) return prev;
        setMainSpecials((prevMain) => prevMain.filter((s) => s !== slot));
        return [...prev, slot];
      });
    }
  };

  const getModeButtonStyle = (mode) => ({
    flex: 1,
    padding: "4px 6px",
    fontSize: 12,
    borderRadius: 6,
    border: "1px solid #3a3a60",
    marginRight: mode === "main" ? 4 : 0,
    background:
      specialMode === mode
        ? mode === "main"
          ? "linear-gradient(135deg, #f5d76e, #c9a64a)"
          : "linear-gradient(135deg, #4ea3ff, #2b6fbf)"
        : "#181820",
    color: specialMode === mode ? "#000" : "#ddd",
    fontWeight: specialMode === mode ? 700 : 500,
  });

  return (
    <div style={{ width: "100%", height: "100%", background: "#111", color: "#fff", fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif", display: "flex", justifyContent: "center", alignItems: "center" }}>
      <div style={{ width: 560, maxHeight: "82vh", background: "#151521", borderRadius: 12, border: "1px solid #3a3a60", boxShadow: "0 14px 40px rgba(0,0,0,0.8)", padding: 16, boxSizing: "border-box", display: "flex", flexDirection: "column" }}>
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "baseline", marginBottom: 8 }}>
          <div>
            <h2 style={{ fontSize: 18, margin: 0 }}>캐릭터</h2>
            <div style={{ fontSize: 11, opacity: 0.75, marginTop: 2 }}>
              주특기 / 보조특기 카드 선택 UI
            </div>
          </div>
        </div>

        <div style={{ borderRadius: 8, padding: 8, marginBottom: 10, background: "#181820", border: "1px solid #303040" }}>
          <div style={statRowStyle}>
            <span style={statLabelStyle}>체력</span>
            <span style={statValueStyle}>{baseStats.hp.current} / {baseStats.hp.max}</span>
          </div>
          <div style={statRowStyle}>
            <span style={statLabelStyle}>에너지</span>
            <span style={statValueStyle}>{baseStats.energy.current} / {baseStats.energy.max}</span>
          </div>
          <div style={statRowStyle}>
            <span style={statLabelStyle}>속도</span>
            <span style={statValueStyle}>{baseStats.speed}</span>
          </div>
          <div style={statRowStyle}>
            <span style={statLabelStyle}>힘</span>
            <span style={statValueStyle}>{baseStats.power}</span>
          </div>
        </div>

        <div style={{ display: "flex", alignItems: "center", marginBottom: 6, gap: 8 }}>
          <div style={{ display: "flex", flex: 1 }}>
            <button type="button" style={getModeButtonStyle("main")} onClick={() => setSpecialMode("main")}>
              주특기 선택 모드
            </button>
            <button type="button" style={getModeButtonStyle("sub")} onClick={() => setSpecialMode("sub")}>
              보조특기 선택 모드
            </button>
          </div>
          <div style={{ fontSize: 11, opacity: 0.8, textAlign: "right", minWidth: 140 }}>
            <div>주특기: {mainSpecials.length} / 3</div>
            <div>보조특기: {subSpecials.length} / 5</div>
          </div>
        </div>

        <h3 style={{ fontSize: 14, margin: "0 0 4px" }}>카드 선택</h3>
        <div style={{ borderRadius: 8, padding: 8, marginBottom: 6, background: "#16161d", border: "1px solid #28283a", flex: 1, overflowY: "auto", maxHeight: "48vh" }}>
          <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(230px, 1fr))", gridAutoRows: "minmax(60px, auto)", columnGap: 6, rowGap: 6 }}>
            {initialDeck.map((card) => (
              <div key={card.slot} style={getCardStyle(card.slot)} onClick={() => handleCardClick(card.slot)}>
                <div style={{ display: "flex", justifyContent: "space-between", marginBottom: 2 }}>
                  <span>
                    <span style={{ opacity: 0.7 }}>슬롯 {card.slot}</span>{" "}
                    <b>{card.name}</b>
                    <span style={{ opacity: 0.6 }}> · {card.type}</span>
                  </span>
                  <span style={{ fontSize: 11, opacity: 0.8 }}>
                    속도 {card.speed} / 행동력 {card.ap}
                  </span>
                </div>
                <div style={{ fontSize: 12, opacity: 0.9 }}>
                  {card.desc}
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

export default DungeonGameCharacterBuild;
`;

      function downloadJSX() {
        const blob = new Blob([jsxFileContent], {
          type: "text/plain;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "DungeonGameCharacterBuild.jsx";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // --- React 컴포넌트 ---
      function DungeonGame() {
        const containerRef = useRef(null);
        const [showChar, setShowChar] = useState(false);

        // 특기 모드: "main" = 주특기, "sub" = 보조특기
        const [specialMode, setSpecialMode] = useState("main");
        const [mainSpecials, setMainSpecials] = useState([]); // 주특기 카드 슬롯 배열
        const [subSpecials, setSubSpecials] = useState([]);   // 보조특기 카드 슬롯 배열

        // Phaser 초기화
        useEffect(() => {
          if (!containerRef.current) return;
          const config = createPhaserConfig(containerRef.current);
          const game = new Phaser.Game(config);
          return () => {
            game.destroy(true);
          };
        }, []);

        // C 키로 캐릭터 창 토글 (처음엔 아무 카드도 선택 X)
        useEffect(() => {
          const handleKeyDown = (e) => {
            if (e.key === "c" || e.key === "C") {
              setShowChar((prev) => !prev);
            }
          };
          window.addEventListener("keydown", handleKeyDown);
          return () => window.removeEventListener("keydown", handleKeyDown);
        }, []);

        // 카드 클릭 → 현재 선택 모드(주/보조)에 따라 토글
        const handleCardClick = (slot) => {
          if (specialMode === "main") {
            setMainSpecials((prev) => {
              if (prev.includes(slot)) {
                return prev.filter((s) => s !== slot);
              }
              if (prev.length >= 3) {
                alert("주특기는 최대 3장까지만 선택할 수 있습니다.");
                return prev;
              }
              setSubSpecials((prevSub) => prevSub.filter((s) => s !== slot));
              return [...prev, slot];
            });
          } else {
            setSubSpecials((prev) => {
              if (prev.includes(slot)) {
                return prev.filter((s) => s !== slot);
              }
              if (prev.length >= 5) {
                alert("보조특기는 최대 5장까지만 선택할 수 있습니다.");
                return prev;
              }
              setMainSpecials((prevMain) => prevMain.filter((s) => s !== slot));
              return [...prev, slot];
            });
          }
        };

        // 카드 스타일 계산 (주특기=노란색, 보조특기=푸른색)
        const getCardStyle = (slot) => {
          const isMain = mainSpecials.includes(slot);
          const isSub = subSpecials.includes(slot);

          let borderColor = "#31314a";
          let boxShadow = "none";
          let background = cardRowBaseStyle.background;

          if (isMain) {
            borderColor = "#f5d76e";
            boxShadow = "0 0 8px rgba(245,215,110,0.9)";
            background = "#2a2615";
          } else if (isSub) {
            borderColor = "#4ea3ff";
            boxShadow = "0 0 8px rgba(78,163,255,0.9)";
            background = "#172538";
          }

          return {
            ...cardRowBaseStyle,
            border: `1px solid ${borderColor}`,
            boxShadow,
            background,
            cursor: "pointer",
          };
        };

        // 특기 모드 버튼 스타일
        const getModeButtonStyle = (mode) => ({
          flex: 1,
          padding: "4px 6px",
          fontSize: 12,
          borderRadius: 6,
          border: "1px solid #3a3a60",
          marginRight: mode === "main" ? 4 : 0,
          background:
            specialMode === mode
              ? mode === "main"
                ? "linear-gradient(135deg, #f5d76e, #c9a64a)"
                : "linear-gradient(135deg, #4ea3ff, #2b6fbf)"
              : "#181820",
          color: specialMode === mode ? "#000" : "#ddd",
          fontWeight: specialMode === mode ? 700 : 500,
        });

        return (
          <div style={rootStyle}>
            <div ref={containerRef} style={gameContainerStyle} />

            {/* 오른쪽 정보 패널 */}
            <div style={uiPanelStyle}>
              <h1 style={{ fontSize: 16, margin: "0 0 6px" }}>
                1통로-1방 일직선 랜덤 던전
              </h1>

              <button
                type="button"
                style={downloadButtonStyle}
                onClick={downloadJSX}
              >
                JSX 캐릭터 창 파일 다운로드
              </button>

              <p style={{ margin: "6px 0 8px", fontSize: 12, opacity: 0.9 }}>
                <b>C</b> 키를 눌러 캐릭터/카드 창을 열고 닫을 수 있습니다.
              </p>

              <h2 style={{ fontSize: 14, margin: "10px 0 4px" }}>조작</h2>
              <ul style={{ paddingLeft: 18, margin: "0 0 10px" }}>
                <li>
                  <code style={codeStyle}>WASD</code> : 이동
                </li>
                <li>
                  <code style={codeStyle}>E</code> : 근처 문 / 오브젝트 / 느낌표(!) / 출구와 상호작용
                </li>
                <li>
                  <code style={codeStyle}>C</code> : 캐릭터 / 카드 창 열기·닫기
                </li>
              </ul>

              <h2 style={{ fontSize: 14, margin: "10px 0 4px" }}>메모</h2>
              <ul style={{ paddingLeft: 18, margin: 0 }}>
                <li>던전 시작 시 전체 방 수 5~9개 랜덤 → 평균 7방 정도 진행</li>
                <li>통로/방에 나타나는 느낌표(!)는 약 25% 확률</li>
                <li>느낌표와 일부 오브젝트는 정신 압박(스트레스 유사치)을 상승/감소시킴</li>
                <li>캐릭터 스탯/카드는 C 키로 언제든 확인 가능</li>
              </ul>
            </div>

            {/* C 키로 여닫는 캐릭터 창 오버레이 */}
            {showChar && (
              <div style={charOverlayStyle}>
                <div style={charWindowStyle}>
                  <div
                    style={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "baseline",
                      marginBottom: 8,
                    }}
                  >
                    <div>
                      <h2
                        style={{
                          fontSize: 18,
                          margin: 0,
                        }}
                      >
                        캐릭터
                      </h2>
                      <div
                        style={{
                          fontSize: 11,
                          opacity: 0.75,
                          marginTop: 2,
                        }}
                      >
                        주특기 / 보조특기 카드 선택 UI (최대 주 3장 · 보조 5장)
                      </div>
                    </div>
                    <div
                      style={{
                        fontSize: 11,
                        opacity: 0.7,
                        textAlign: "right",
                      }}
                    >
                      <div>
                        <code style={codeStyle}>C</code> 키로 닫기
                      </div>
                    </div>
                  </div>

                  {/* 상단: 스탯 */}
                  <div
                    style={{
                      borderRadius: 8,
                      padding: 8,
                      marginBottom: 10,
                      background: "#181820",
                      border: "1px solid #303040",
                    }}
                  >
                    <div style={statRowStyle}>
                      <span style={statLabelStyle}>체력</span>
                      <span style={statValueStyle}>
                        {baseStats.hp.current} / {baseStats.hp.max}
                      </span>
                    </div>
                    <div style={statRowStyle}>
                      <span style={statLabelStyle}>에너지</span>
                      <span style={statValueStyle}>
                        {baseStats.energy.current} / {baseStats.energy.max}
                      </span>
                    </div>
                    <div style={statRowStyle}>
                      <span style={statLabelStyle}>속도</span>
                      <span style={statValueStyle}>{baseStats.speed}</span>
                    </div>
                    <div style={statRowStyle}>
                      <span style={statLabelStyle}>힘</span>
                      <span style={statValueStyle}>{baseStats.power}</span>
                    </div>
                  </div>

                  {/* 특기 선택 모드 스위치 + 카운트 */}
                  <div
                    style={{
                      display: "flex",
                      alignItems: "center",
                      marginBottom: 6,
                      gap: 8,
                    }}
                  >
                    <div style={{ display: "flex", flex: 1 }}>
                      <button
                        type="button"
                        style={getModeButtonStyle("main")}
                        onClick={() => setSpecialMode("main")}
                      >
                        주특기 선택 모드
                      </button>
                      <button
                        type="button"
                        style={getModeButtonStyle("sub")}
                        onClick={() => setSpecialMode("sub")}
                      >
                        보조특기 선택 모드
                      </button>
                    </div>
                    <div
                      style={{
                        fontSize: 11,
                        opacity: 0.8,
                        textAlign: "right",
                        minWidth: 140,
                      }}
                    >
                      <div>주특기: {mainSpecials.length} / 3</div>
                      <div>보조특기: {subSpecials.length} / 5</div>
                    </div>
                  </div>

                  {/* 카드 덱 영역 - 더 많은 카드도 수용 가능한 그리드 + 스크롤 */}
                  <h3
                    style={{
                      fontSize: 14,
                      margin: "0 0 4px",
                    }}
                  >
                    카드 선택
                  </h3>
                  <div
                    style={{
                      borderRadius: 8,
                      padding: 8,
                      marginBottom: 6,
                      background: "#16161d",
                      border: "1px solid #28283a",
                      flex: 1,
                      overflowY: "auto",
                      maxHeight: "48vh",
                    }}
                  >
                    <div
                      style={{
                        display: "grid",
                        gridTemplateColumns: "repeat(auto-fill, minmax(230px, 1fr))",
                        gridAutoRows: "minmax(60px, auto)",
                        columnGap: 6,
                        rowGap: 6,
                      }}
                    >
                      {initialDeck.map((card) => (
                        <div
                          key={card.slot}
                          style={getCardStyle(card.slot)}
                          onClick={() => handleCardClick(card.slot)}
                        >
                          <div
                            style={{
                              display: "flex",
                              justifyContent: "space-between",
                              marginBottom: 2,
                            }}
                          >
                            <span>
                              <span style={{ opacity: 0.7 }}>
                                슬롯 {card.slot}
                              </span>{" "}
                              <b>{card.name}</b>
                              <span style={{ opacity: 0.6 }}>
                                {" "}
                                · {card.type}
                              </span>
                            </span>
                            <span style={{ fontSize: 11, opacity: 0.8 }}>
                              속도 {card.speed} / 행동력 {card.ap}
                            </span>
                          </div>
                          <div style={{ fontSize: 12, opacity: 0.9 }}>
                            {card.desc}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  <div
                    style={{
                      fontSize: 11,
                      opacity: 0.8,
                      marginTop: 2,
                    }}
                  >
                    · 주특기 모드에서 카드를 클릭하면 노란색으로 빛나며 주특기로 선택됩니다. (최대 3장)
                    <br />
                    · 보조특기 모드에서 카드를 클릭하면 푸른색으로 빛나며 보조특기로 선택됩니다. (최대 5장)
                    <br />
                    · 한 카드는 주특기 또는 보조특기 중 하나만 가질 수 있습니다. 다시 클릭하면 해제됩니다.
                  </div>

                  <div
                    style={{
                      fontSize: 11,
                      opacity: 0.75,
                      marginTop: 4,
                      textAlign: "right",
                    }}
                  >
                    C 키로 언제든 이 창을 열고 닫을 수 있습니다.
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<DungeonGame />);
    </script>
  </body>
</html>
