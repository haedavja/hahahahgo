<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í„´ì œ ì¹´ë“œ ì „íˆ¬ ê²Œì„</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #0a0a0a;
        }

        /* ì¹´ë“œ ìŠ¤íƒ€ì¼ ê°œì„  */
        .card-enhanced {
            background: linear-gradient(145deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 3px solid #444;
            border-radius: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .card-enhanced::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
        }

        .card-enhanced:hover:not(.disabled) {
            transform: translateY(-5px) scale(1.02);
            border-color: #fbbf24;
            box-shadow: 0 10px 30px rgba(251, 191, 36, 0.3);
        }

        .card-enhanced.selected {
            border-color: #3b82f6;
            background: linear-gradient(145deg, #1e3a8a 0%, #1e40af 100%);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }

        .card-enhanced.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* ê³µê²© ì¹´ë“œ */
        .attack-card {
            border-color: #ef4444 !important;
            background: linear-gradient(145deg, #7f1d1d 0%, #991b1b 100%) !important;
        }

        .attack-card:hover:not(.disabled) {
            border-color: #f87171 !important;
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4) !important;
        }

        /* ë°©ì–´ ì¹´ë“œ */
        .defense-card {
            border-color: #3b82f6 !important;
            background: linear-gradient(145deg, #1e3a8a 0%, #1e40af 100%) !important;
        }

        .defense-card:hover:not(.disabled) {
            border-color: #60a5fa !important;
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.4) !important;
        }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .btn-enhanced {
            background: linear-gradient(145deg, #1e40af, #1e3a8a);
            border: 2px solid #3b82f6;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 700;
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .btn-enhanced:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }

        .btn-enhanced:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(145deg, #f59e0b, #d97706);
            border-color: #fbbf24;
        }

        .btn-success {
            background: linear-gradient(145deg, #059669, #047857);
            border-color: #10b981;
        }

        /* ì½”ìŠ¤íŠ¸ ë°°ì§€ */
        .cost-badge {
            background: radial-gradient(circle, #fbbf24, #f59e0b);
            border: 2px solid #fff;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 14px;
            color: #000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        /* HP ë°” ê°œì„  */
        .hp-bar-enhanced {
            position: relative;
            height: 20px;
            background: linear-gradient(to right, #450a0a, #7f1d1d);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #450a0a;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc2626 0%, #ef4444 50%, #f87171 100%);
            transition: width 0.5s ease;
            position: relative;
        }

        .hp-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
        }

        /* ì½¤ë³´ ë°°ì§€ */
        .combo-badge {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 900;
            font-size: 11px;
            color: #000;
            box-shadow: 0 2px 8px rgba(251, 191, 36, 0.5);
            display: inline-block;
        }

        /* íŒ¨ë„ */
        .panel-enhanced {
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border: 2px solid #334155;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        /* ê²Œì„ ì¹´ë“œ - ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ */
        .game-card-large {
            position: relative;
            width: 140px;
            height: 200px;
            border-radius: 16px;
            border: 4px solid;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .game-card-large.attack {
            border-color: #ff6b6b;
            background: linear-gradient(180deg, #8B0000 0%, #4a0000 100%);
        }

        .game-card-large.defense {
            border-color: #4dabf7;
            background: linear-gradient(180deg, #1e40af 0%, #0c1e4a 100%);
        }

        .game-card-large:hover:not(.disabled) {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 15px 40px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .game-card-large.selected {
            transform: translateY(-20px);
            box-shadow: 0 20px 50px rgba(251, 191, 36, 0.8);
            border-color: #fbbf24;
        }

        .game-card-large.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .card-header {
            padding: 8px;
            text-align: center;
            position: relative;
        }

        .card-cost-corner {
            position: absolute;
            top: -4px;
            left: -4px;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #fbbf24, #f59e0b);
            border-radius: 50%;
            border: 3px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 20px;
            color: #000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.8);
            z-index: 2;
        }

        .card-icon-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
        }

        .card-footer {
            background: rgba(0,0,0,0.5);
            padding: 8px;
            text-align: center;
            border-top: 2px solid rgba(255,255,255,0.1);
        }

        /* ì—ë„ˆì§€ êµ¬ìŠ¬ - í° ë²„ì „ */
        .energy-orb-large {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fef08a, #fbbf24, #f59e0b, #d97706);
            box-shadow: 0 0 30px rgba(251, 191, 36, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 32px;
            color: #000;
            text-shadow: 0 2px 4px rgba(255,255,255,0.5);
            border: 4px solid rgba(255,255,255,0.3);
        }

        /* ë°°í‹€ ì˜ì—­ */
        .battle-arena {
            position: relative;
            min-height: 500px;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.8) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-radius: 20px;
            border: 3px solid #475569;
            padding: 32px 48px !important;
        }

        /* ì†íŒ¨ ì˜ì—­ */
        .hand-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.98) 100%);
            padding: 20px;
            border-top: 3px solid #475569;
            z-index: 100;
        }

        .hand-cards {
            display: flex;
            justify-content: center;
            gap: 12px;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
        }

        /* ìºë¦­í„° ì˜ì—­ */
        .character-display {
            font-size: 80px;
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.8));
        }

        /* ì—í…Œë¥´ ë°” ì„¸ë¡œí˜• */
        .ether-bar-vertical {
            width: 50px;
            height: 300px;
            background: linear-gradient(to top, #0c4a6e, #075985);
            border-radius: 25px;
            border: 3px solid;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .ether-bar-vertical.player {
            border-color: #22d3ee;
        }

        .ether-bar-vertical.enemy {
            border-color: #e879f9;
        }

        .ether-fill-vertical {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            transition: height 0.5s ease;
        }

        .ether-fill-vertical.player {
            background: linear-gradient(to top, #06b6d4, #22d3ee, #67e8f9);
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.6);
        }

        .ether-fill-vertical.enemy {
            background: linear-gradient(to top, #c026d3, #e879f9, #f0abfc);
            box-shadow: 0 0 20px rgba(232, 121, 249, 0.6);
        }

        /* ì„ íƒ ë²ˆí˜¸ ë°°ì§€ - ì¹´ë“œ ì¤‘ì‹¬ */
        .selection-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 52px;
            height: 52px;
            background: linear-gradient(135deg, #10b981, #059669);
            border: 3px solid #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 28px;
            color: #fff;
            box-shadow: 0 6px 20px rgba(0,0,0,0.8);
            z-index: 3;
        }

        /* ì¡°í•© í‘œì‹œ - ì†íŒ¨ ì¤‘ì•™ */
        .combo-display {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            padding: 12px 20px;
            border-radius: 12px;
            font-weight: 900;
            font-size: 20px;
            color: #000;
            box-shadow: 0 4px 16px rgba(251, 191, 36, 0.8);
            border: 3px solid #fff;
            animation: pulse-glow 2s infinite;
            margin-top: -8px;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 4px 16px rgba(251, 191, 36, 0.8); }
            50% { box-shadow: 0 8px 32px rgba(251, 191, 36, 1); }
        }

        /* ì œì¶œëœ ì¹´ë“œ ì˜ì—­ */
        .submitted-cards-area {
            background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.98) 100%);
            border-top: 3px solid #fbbf24;
            padding: 20px;
        }

        /* ì¹´ë“œ ì´ë™ ë²„íŠ¼ */
        .card-move-btn {
            background: rgba(59, 130, 246, 0.8);
            border: 2px solid #3b82f6;
            color: white;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-move-btn:hover:not(:disabled) {
            background: rgba(59, 130, 246, 1);
            transform: scale(1.1);
        }

        .card-move-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* ì¹´ë“œ ì‚¬ìš© ì´í™íŠ¸ */
        @keyframes card-use-effect {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3) rotate(5deg); opacity: 0.8; }
            100% { transform: scale(0.5) translateY(-50px); opacity: 0; }
        }

        .card-used {
            animation: card-use-effect 0.8s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // Lucide icons as simple SVG components
        const Sword = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M14.5 17.5 3 6V3h3l11.5 11.5M13 19l6-6M16 16l4 4M19 21l2-2"/>
            </svg>
        );

        const Shield = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
            </svg>
        );

        const Heart = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
            </svg>
        );

        const Zap = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
            </svg>
        );

        const Flame = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"/>
            </svg>
        );

        const Clock = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"/>
                <polyline points="12 6 12 12 16 14"/>
            </svg>
        );

        const Skull = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/>
                <path d="M8 20v2h8v-2M12.5 17l-.5-1-.5 1h1z"/>
                <path d="M16 18a8 8 0 1 0-8 0v2h8v-2z"/>
            </svg>
        );

        const X = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
        );

        const ChevronUp = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="18 15 12 9 6 15"/>
            </svg>
        );

        const ChevronDown = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        );

        const Play = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>
        );

        const StepForward = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/>
            </svg>
        );

        const RefreshCw = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
            </svg>
        );

        // =====================
        // Constants / Config
        // =====================
        const MAX_SPEED = 30;
        const BASE_PLAYER_ENERGY = 6;
        const MAX_SUBMIT_CARDS = 5;
        const ETHER_THRESHOLD = 100;

        // =====================
        // Cards
        // =====================
        const CARDS = [
          { id: "quick",   name: "Quick Slash",    type: "attack",  damage: 3,              speedCost: 3,  actionCost: 1, icon: Sword },
          { id: "slash",   name: "Slash",          type: "attack",  damage: 5,              speedCost: 5,  actionCost: 2, icon: Sword },
          { id: "heavy",   name: "Heavy Strike",   type: "attack",  damage: 8,              speedCost: 10, actionCost: 2, icon: Flame },
          { id: "double",  name: "Double Slash",   type: "attack",  damage: 3, hits: 2,     speedCost: 7,  actionCost: 2, icon: Sword },
          { id: "precise", name: "Precise Strike", type: "attack",  damage: 6,              speedCost: 6,  actionCost: 2, icon: Sword },
          { id: "rush",    name: "Rush Attack",    type: "attack",  damage: 4,              speedCost: 4,  actionCost: 1, icon: Flame },
          { id: "parry",   name: "Parry",          type: "defense", block: 5,               speedCost: 2,  actionCost: 1, icon: Shield, counter: 0 },
          { id: "guard",   name: "Guard",          type: "defense", block: 8,               speedCost: 6,  actionCost: 1, icon: Shield },
          { id: "wall",    name: "Iron Wall",      type: "defense", block: 12,              speedCost: 9,  actionCost: 2, icon: Shield },
          { id: "counter", name: "Counter Stance", type: "defense", block: 4, counter: 3,   speedCost: 4,  actionCost: 1, icon: Shield },
        ];

        const ENEMY_CARDS = [
          { id: "e1", name: "Attack",  type: "attack",  damage: 3, speedCost: 3, actionCost: 1, icon: Sword },
          { id: "e2", name: "Heavy",   type: "attack",  damage: 6, speedCost: 8, actionCost: 2, icon: Flame },
          { id: "e3", name: "Guard",   type: "defense", block: 4, speedCost: 2, actionCost: 1, icon: Shield },
          { id: "e4", name: "Strike",  type: "attack",  damage: 4, speedCost: 5, actionCost: 1, icon: Sword },
          { id: "e5", name: "Defense", type: "defense", block: 6, speedCost: 6, actionCost: 1, icon: Shield },
          { id: "e6", name: "Barrier", type: "defense", block: 8, speedCost: 9, actionCost: 2, icon: Shield },
        ];

        const ENEMIES = [
          { name: "Goblin", hp: 20, deck: ["e1", "e3", "e4"] },
          { name: "Orc",    hp: 30, deck: ["e2", "e4", "e5"] },
          { name: "Dragon", hp: 50, deck: ["e2", "e2", "e5", "e6", "e4"] },
        ];

        // =====================
        // Utilities
        // =====================
        const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];

        function sortCombinedOrderStablePF(playerCards, enemyCards) {
          const q = []; let ps = 0, es = 0;
          (playerCards||[]).forEach((c, idx) => { ps += c.speedCost; q.push({ actor: 'player', card: c, sp: ps, idx }); });
          (enemyCards||[]).forEach((c, idx) => { es += c.speedCost; q.push({ actor: 'enemy',  card: c, sp: es, idx }); });
          q.sort((a, b) => {
            if (a.sp !== b.sp) return a.sp - b.sp;
            if (a.actor !== b.actor) return a.actor === 'player' ? -1 : 1;
            return a.idx - b.idx;
          });
          return q;
        }

        // =====================
        // Poker combo helpers
        // =====================
        function detectPokerCombo(cards){
          if(!cards || cards.length < 2) return null;
          const freq = new Map();
          for(const c of cards){ freq.set(c.actionCost, (freq.get(c.actionCost)||0)+1); }
          const counts = Array.from(freq.values());
          const have = (n)=>counts.includes(n);
          const keysByCount = (n)=> new Set(Array.from(freq.entries()).filter(([k,v])=>v===n).map(([k])=>Number(k)));

          const allAttack = cards.every(c=>c.type==='attack');
          const allDefense = cards.every(c=>c.type==='defense');
          const isFlush = (allAttack || allDefense) && cards.length>=4;

          if(have(5)) return { name:'íŒŒì´ë¸Œì¹´ë“œ', bonusKeys: keysByCount(5) };
          if(have(4)) return { name:'í¬ì¹´ë“œ',   bonusKeys: keysByCount(4) };
          if(have(3) && have(2)){
            const b = new Set([...keysByCount(3), ...keysByCount(2)]);
            return { name:'í’€í•˜ìš°ìŠ¤', bonusKeys: b };
          }
          if(isFlush) return { name:'í”ŒëŸ¬ì‰¬', bonusKeys: null };
          const pairKeys = keysByCount(2);
          if(pairKeys.size >= 2) return { name:'íˆ¬í˜ì–´',  bonusKeys: pairKeys };
          if(have(3)) return { name:'íŠ¸ë¦¬í”Œ',  bonusKeys: keysByCount(3) };
          if(have(2)) return { name:'í˜ì–´',    bonusKeys: pairKeys };
          return null;
        }

        function applyPokerBonus(cards, combo){
          if(!combo) return cards;
          return cards.map(c=>{
            if(combo.bonusKeys && combo.bonusKeys.has(c.actionCost)){
              if(c.type==='attack') return { ...c, damage:(c.damage||0)+1, _combo: combo.name };
              if(c.type==='defense') return { ...c, block:(c.block||0)+1, _combo: combo.name };
            }
            return c;
          });
        }

        const ETHER_GAIN_MAP = {
          'í˜ì–´': 10,
          'íˆ¬í˜ì–´': 10,
          'íŠ¸ë¦¬í”Œ': 20,
          'í”ŒëŸ¬ì‰¬': 30,
          'í’€í•˜ìš°ìŠ¤': 40,
          'í¬ì¹´ë“œ': 50,
          'íŒŒì´ë¸Œì¹´ë“œ': 60,
        };
        function etherSlots(pts){ return Math.floor((pts||0) / ETHER_THRESHOLD); }
        function addEther(pts, add){ return (pts||0) + (add||0); }

        // =====================
        // Combat Logic
        // =====================
        function applyAction(state, actor, card){
          const A = actor==='player' ? state.player : state.enemy;
          const B = actor==='player' ? state.enemy  : state.player;
          const events = [];

          if(card.type==='defense'){
            const prev = A.block || 0;
            const added = card.block || 0;
            const after = prev + added;
            A.def = true; A.block = after;
            if(card.counter!==undefined){ A.counter = card.counter || 0; }
            const who = actor==='player' ? 'í”Œë ˆì´ì–´' : 'ëª¬ìŠ¤í„°';
            const msg = prev===0 ? `${who} â€¢ ğŸ›¡ï¸ +${added} = ${after}` : `${who} â€¢ ğŸ›¡ï¸ ${prev} + ${added} = ${after}`;
            events.push({ actor, card:card.name, type:'defense', msg });
            state.log.push(`${actor==='player'?'ğŸ”µ':'ğŸ‘¾'} ${card.name} â†’ ${msg}`);
            return { dealt:0, taken:0, events };
          }

          if(card.type==='attack'){
            let totalDealt = 0, totalTaken = 0;
            const hits = card.hits || 1;

            for(let i=0;i<hits;i++){
              const base = card.damage;
              const boost = (A.etherOverdriveActive) ? 2 : 1;
              let dmg = base * boost;

              if(B.def && (B.block||0) > 0){
                const beforeBlock = B.block;
                if(dmg < beforeBlock){
                  const remaining = beforeBlock - dmg;
                  B.block = remaining; dmg = 0;
                  A.vulnMult = 1 + (remaining * 0.5); A.vulnTurns = 1;
                  const formula = `(ë°©ì–´ë ¥ ${beforeBlock} - ê³µê²©ë ¥ ${base}${boost>1?'Ã—2':''} = ${remaining})`;
                  const msg = `${actor==='player' ? 'í”Œë ˆì´ì–´ -> ëª¬ìŠ¤í„°' : 'ëª¬ìŠ¤í„° -> í”Œë ˆì´ì–´'} â€¢ ì°¨ë‹¨ ì„±ê³µ ${formula} + ì·¨ì•½ Ã—${A.vulnMult.toFixed(1)}`;
                  events.push({ actor, card:card.name, type:'blocked', msg });
                  state.log.push(`${actor==='player'?'ğŸ”µ':'ğŸ‘¾'} ${card.name} â†’ ${msg}`);
                } else {
                  const blocked = beforeBlock;
                  const remained = Math.max(0, dmg - blocked);
                  const formula = `(ë°©ì–´ë ¥ ${blocked} - ê³µê²©ë ¥ ${base}${boost>1?'Ã—2':''} = 0)`;
                  B.block = 0;
                  const vulnMul = (B.vulnMult && B.vulnMult>1) ? B.vulnMult : 1;
                  const finalDmg = Math.floor(remained * vulnMul);
                  const beforeHP = B.hp; B.hp = Math.max(0, B.hp - finalDmg);
                  const msg = `${actor==='player' ? 'í”Œë ˆì´ì–´ -> ëª¬ìŠ¤í„°' : 'ëª¬ìŠ¤í„° -> í”Œë ˆì´ì–´'} â€¢ ì°¨ë‹¨ ${blocked} ${formula}, ê´€í†µ ${finalDmg} (ì²´ë ¥ ${beforeHP} -> ${B.hp})`;
                  events.push({ actor, card:card.name, type:'pierce', dmg:finalDmg, beforeHP, afterHP:B.hp, msg });
                  state.log.push(`${actor==='player'?'ğŸ”µ':'ğŸ‘¾'} ${card.name} â†’ ${msg}`);
                  if(B.counter && finalDmg>0){
                    const beforeAHP = A.hp; A.hp = Math.max(0, A.hp - B.counter); totalTaken += B.counter;
                    const cmsg = `${actor==='player' ? 'ëª¬ìŠ¤í„° -> í”Œë ˆì´ì–´' : 'í”Œë ˆì´ì–´ -> ëª¬ìŠ¤í„°'} â€¢ ë°˜ê²© ${B.counter} (ì²´ë ¥ ${beforeAHP} -> ${A.hp})`;
                    events.push({ actor:'counter', value:B.counter, msg:cmsg });
                    state.log.push(`${actor==='player'?'ğŸ”µ':'ğŸ‘¾'} ${cmsg}`);
                  }
                  totalDealt += finalDmg;
                }
              } else {
                const vulnMul = (B.vulnMult && B.vulnMult>1) ? B.vulnMult : 1;
                const finalDmg = Math.floor(dmg * vulnMul);
                const beforeHP = B.hp; B.hp = Math.max(0, B.hp - finalDmg);
                const msg = `${actor==='player' ? 'í”Œë ˆì´ì–´ -> ëª¬ìŠ¤í„°' : 'ëª¬ìŠ¤í„° -> í”Œë ˆì´ì–´'} â€¢ ë°ë¯¸ì§€ ${finalDmg}${boost>1?' (ì—í…Œë¥´ í­ì£¼Ã—2)':''} (ì²´ë ¥ ${beforeHP} -> ${B.hp})`;
                events.push({ actor, card:card.name, type:'hit', dmg:finalDmg, beforeHP, afterHP:B.hp, msg });
                state.log.push(`${actor==='player'?'ğŸ”µ':'ğŸ‘¾'} ${card.name} â†’ ${msg}`);
                if(B.counter && finalDmg>0){
                  const beforeAHP = A.hp; A.hp = Math.max(0, A.hp - B.counter); totalTaken += B.counter;
                  const cmsg = `${actor==='player'?'ëª¬ìŠ¤í„°â†’í”Œë ˆì´ì–´':'í”Œë ˆì´ì–´â†’ëª¬ìŠ¤í„°'} â€¢ ë°˜ê²© ${B.counter} (ì²´ë ¥ ${beforeAHP} -> ${A.hp})`;
                  events.push({ actor:'counter', value:B.counter, msg:cmsg });
                  state.log.push(`${actor==='player'?'ğŸ”µ':'ğŸ‘¾'} ${cmsg}`);
                }
                totalDealt += finalDmg;
              }
            }
            return { dealt: totalDealt, taken: totalTaken, events };
          }

          return { dealt:0, taken:0, events };
        }

        // AI: ì„±í–¥ ê²°ì • & í–‰ë™ ìƒì„±
        function decideEnemyMode(){
          return choice([
            {name:'ê³µê²©ì ', key:'aggro',    prefer:'attack'},
            {name:'ìˆ˜ë¹„ì ', key:'turtle',   prefer:'defense'},
            {name:'ê· í˜•ì ', key:'balanced', prefer:'mixed'}
          ]);
        }

        function combosUpTo3(arr){
          const out=[]; const n=arr.length;
          for(let i=0;i<n;i++){
            out.push([arr[i]]);
            for(let j=i+1;j<n;j++){
              out.push([arr[i],arr[j]]);
              for(let k=j+1;k<n;k++) out.push([arr[i],arr[j],arr[k]]);
            }
          }
          return out;
        }

        function generateEnemyActions(enemy, mode, enemyEtherSlots=0){
          if(!enemy) return [];
          const energyBudget = BASE_PLAYER_ENERGY + (enemyEtherSlots||0);
          const deck = (enemy.deck||[])
            .map(id=>ENEMY_CARDS.find(c=>c.id===id))
            .filter(Boolean);
          if(deck.length===0) return [];

          const half = Math.ceil(energyBudget/2);
          const candidates = combosUpTo3(deck).filter(cards=>{
            const sp = cards.reduce((s,c)=>s+c.speedCost,0);
            const en = cards.reduce((s,c)=>s+c.actionCost,0);
            return sp<=MAX_SPEED && en<=energyBudget;
          });

          function stat(list){
            const atk = list.filter(c=>c.type==='attack').reduce((a,c)=>a+c.actionCost,0);
            const def = list.filter(c=>c.type==='defense').reduce((a,c)=>a+c.actionCost,0);
            const dmg = list.filter(c=>c.type==='attack').reduce((a,c)=>a + (c.damage||0)*(c.hits||1),0);
            const blk = list.filter(c=>c.type==='defense').reduce((a,c)=>a + (c.block||0),0);
            const sp  = list.reduce((a,c)=>a+c.speedCost,0);
            const en  = list.reduce((a,c)=>a+c.actionCost,0);
            return {atk,def,dmg,blk,sp,en};
          }

          function satisfies(m,list){
            const s = stat(list);
            if(m?.key==='aggro') return s.atk >= half;
            if(m?.key==='turtle') return s.def >= half;
            if(m?.key==='balanced') return s.atk === s.def;
            return true;
          }

          function score(m,list){
            const s = stat(list);
            let base=0;
            if(m?.key==='aggro') base = s.atk*100 + s.dmg*10 - s.sp;
            else if(m?.key==='turtle') base = s.def*100 + s.blk*10 - s.sp;
            else base = (s.dmg+s.blk)*10 - s.sp;
            return base;
          }

          const satisfied = candidates.filter(c=>satisfies(mode,c));
          if(satisfied.length>0){
            satisfied.sort((a,b)=>{
              if(a.length!==b.length) return a.length - b.length;
              const sa=score(mode,a), sb=score(mode,b);
              if(sa!==sb) return sb-sa;
              const saStat=stat(a), sbStat=stat(b);
              if(saStat.sp!==sbStat.sp) return saStat.sp - sbStat.sp;
              if(saStat.en!==sbStat.en) return saStat.en - sbStat.en;
              const aKey=a.map(c=>c.id).join(','), bKey=b.map(c=>c.id).join(',');
              return aKey<bKey? -1 : aKey>bKey? 1 : 0;
            });
            return satisfied[0];
          }

          if(candidates.length>0){
            candidates.sort((a,b)=> score(mode,b)-score(mode,a));
            return candidates[0];
          }
          const single = deck
            .filter(c=>c.speedCost<=MAX_SPEED && c.actionCost<=energyBudget)
            .sort((a,b)=> a.speedCost-b.speedCost || a.actionCost-b.actionCost)[0];
          return single ? [single] : [];
        }

        function shouldEnemyOverdrive(mode, actions, etherPts){
          const slots = etherSlots(etherPts);
          if(slots<=0) return false;
          if(!mode) return false;
          if(mode.key==='aggro') return true;
          if(mode.key==='balanced') return (actions||[]).some(c=>c.type==='attack');
          return false;
        }

        function simulatePreview({player, enemy, fixedOrder, willOverdrive, enemyMode, enemyActions}){
          if(!fixedOrder || fixedOrder.length===0){
            return { pDealt:0, pTaken:0, finalPHp:player.hp, finalEHp:enemy.hp, lines:[] };
          }
          const enemyWillOD = shouldEnemyOverdrive(enemyMode, enemyActions, enemy.etherPts);
          const P = { ...player, def:false, block:0, counter:0, etherOverdriveActive: !!willOverdrive };
          const E = { ...enemy,  def:false, block:0, counter:0, etherOverdriveActive: enemyWillOD };
          const st = { player:P, enemy:E, log:[] };
          let pDealt=0, pTaken=0; const lines=[];
          for(const step of fixedOrder){
            const {events, dealt} = applyAction(st, step.actor, step.card);
            if(step.actor==='player') pDealt += dealt; else pTaken += dealt;
            events.forEach(ev=> lines.push(ev.msg));
            if(st.player.hp<=0 || st.enemy.hp<=0) break;
          }
          return { pDealt, pTaken, finalPHp: st.player.hp, finalEHp: st.enemy.hp, lines };
        }

        function ExpectedDamagePreview({player, enemy, fixedOrder, willOverdrive, enemyMode, enemyActions}){
          const res = useMemo(()=> simulatePreview({player, enemy, fixedOrder, willOverdrive, enemyMode, enemyActions}), [player, enemy, fixedOrder, willOverdrive, enemyMode, enemyActions]);
          return (
            <div className="bg-slate-900 rounded p-3 text-slate-200 text-sm mb-2">
              <div className="flex flex-wrap gap-4">
                <div>ğŸ—¡ï¸ í”Œë ˆì´ì–´ ì˜ˆìƒ ê°€í•œ í”¼í•´: <span className="text-emerald-300 font-bold">{res.pDealt}</span></div>
                <div>ğŸ’¥ í”Œë ˆì´ì–´ ì˜ˆìƒ ë°›ì€ í”¼í•´: <span className="text-rose-300 font-bold">{res.pTaken}</span></div>
              </div>
              <div className="mt-1 flex flex-wrap gap-4">
                <div>í”Œë ˆì´ì–´ HP <span className="text-cyan-400">{player.hp}</span> â†’ <span className="font-bold">{res.finalPHp}</span></div>
                <div>ëª¬ìŠ¤í„° HP <span className="text-orange-400">{enemy.hp}</span> â†’ <span className="font-bold">{res.finalEHp}</span></div>
                {willOverdrive && <div className="text-cyan-300">(í­ì£¼ ì ìš© ë¯¸ë¦¬ë³´ê¸°)</div>}
              </div>
            </div>
          );
        }

        function EtherBar({ pts, color="cyan", label }){
          const slots = etherSlots(pts);
          const VISIBLE_SLOTS = 8;
          const percent = Math.min((pts / (ETHER_THRESHOLD * VISIBLE_SLOTS)) * 100, 100);
          const palette = color === 'fuchsia' ? {
            base:'bg-fuchsia-500', dim:'bg-fuchsia-900/40', ring:'ring-fuchsia-300', text:'text-fuchsia-300'
          } : {
            base:'bg-cyan-500', dim:'bg-cyan-900/40', ring:'ring-cyan-300', text:'text-cyan-300'
          };

          return (
            <div className="flex flex-col items-center w-12">
              <div className={`text-xs ${palette.text} font-bold mb-1 text-center`}>{label}</div>
              <div className={`relative h-64 w-6 rounded ring-2 ${palette.ring} overflow-hidden bg-slate-900`}>
                {Array.from({length:VISIBLE_SLOTS}).map((_,i)=> (
                  <div key={i} className="absolute left-0 right-0 border-t border-slate-700/60" style={{bottom:`${(i/ VISIBLE_SLOTS)*100}%`}} />
                ))}
                <div className={`${palette.base} absolute left-0 right-0`} style={{ bottom:0, height:`${percent}%` }} />
              </div>
              <div className={`text-xs mt-1 ${palette.text}`}>ëˆ„ì  {pts}pt (ìŠ¬ë¡¯ x{slots})</div>
            </div>
          );
        }

        function TestBadge(){
          return (
            <div className="fixed top-2 right-2 bg-amber-500/90 text-black font-bold text-xs px-2 py-1 rounded shadow">
              ì €ì¥ 1.6 ë¶ˆì•ˆì • â€¢ ë¯¸ë‹ˆë©€ í”„ë¦¬ë·°
            </div>
          );
        }

        // =====================
        // Game Component
        // =====================
        function Game(){
          const [player, setPlayer] = useState({ hp:30, maxHp:30, energy:BASE_PLAYER_ENERGY, maxEnergy:BASE_PLAYER_ENERGY, vulnMult:1, vulnTurns:0, block:0, counter:0, etherPts:0, etherOverdriveActive:false });
          const [enemyIndex, setEnemyIndex] = useState(0);
          const [enemy, setEnemy] = useState(null);

          const [phase, setPhase] = useState('select');

          const [hand, setHand] = useState([]);
          const [selected, setSelected] = useState([]);
          const [canRedraw, setCanRedraw] = useState(true);

          const [enemyPlan, setEnemyPlan] = useState({ actions:[], mode:null });
          const [fixedOrder, setFixedOrder] = useState(null);

          const [postCombatOptions, setPostCombatOptions] = useState(null);
          const [log, setLog] = useState(["ê²Œì„ ì‹œì‘!"]);
          const [actionEvents, setActionEvents] = useState({});

          const [queue, setQueue] = useState([]);
          const [qIndex, setQIndex] = useState(0);
          const addLog = (m) => setLog(p => [...p, m].slice(-200));
          const [willOverdrive, setWillOverdrive] = useState(false);
          const [usedCardIndices, setUsedCardIndices] = useState([]);
          const logEndRef = useRef(null);

          useEffect(()=>{
            logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
          }, [log]);

          useEffect(()=>{
            if(!enemy){
              const e = ENEMIES[enemyIndex];
              setEnemy({ ...e, hp:e.hp, maxHp:e.hp, vulnMult:1, vulnTurns:0, block:0, counter:0, etherPts:0, etherOverdriveActive:false });
              setHand(CARDS.slice(0,8));
              setSelected([]);
              setCanRedraw(true);
              addLog('ğŸ´ ì‹œì‘ ì†íŒ¨ 8ì¥');
            }
          },[]);

          useEffect(()=>{
            if(!enemy || phase!=='select') return;
            setFixedOrder(null);
            setActionEvents({});
            setCanRedraw(true);
            setWillOverdrive(false);
            setPlayer(p=>({ ...p, energy: BASE_PLAYER_ENERGY + etherSlots(p.etherPts), etherOverdriveActive:false }));

            setEnemyPlan(prev=>{
              if(prev.mode){
                return { ...prev, actions:[] };
              } else {
                const mode = decideEnemyMode();
                addLog(`ğŸ¤– ì  ì„±í–¥ íŒíŠ¸: ${mode.name}`);
                return { actions:[], mode };
              }
            });
          }, [phase, enemy, enemyPlan.mode]);

          useEffect(()=>{
            if(phase==='resolve' && (!queue || queue.length===0) && fixedOrder && fixedOrder.length>0){
              const rebuilt = fixedOrder.map(x=>({ actor:x.actor, card:x.card, sp:x.sp }));
              setQueue(rebuilt); setQIndex(0);
              addLog('ğŸ§¯ ìë™ ë³µêµ¬: ì‹¤í–‰ íë¥¼ ë‹¤ì‹œ ìƒì„±í–ˆìŠµë‹ˆë‹¤');
            }
          }, [phase, queue, fixedOrder]);

          const totalEnergy = useMemo(()=>selected.reduce((s,c)=>s+c.actionCost,0),[selected]);
          const totalSpeed  = useMemo(()=>selected.reduce((s,c)=>s+c.speedCost ,0),[selected]);
          const currentCombo = useMemo(()=>detectPokerCombo(selected),[selected]);

          const toggle = (card)=>{
            if(phase!=='select' && phase!=='respond') return;
            const exists = selected.some(s=>s.id===card.id);
            if(phase==='respond'){
              setSelected(prev=>{
                let next;
                if(exists){ next = prev.filter(s=>!(s.__uid===card.__uid) && !(s.id===card.id && !('__uid' in s))); }
                else {
                  if(prev.length >= MAX_SUBMIT_CARDS){ addLog('âš ï¸ ìµœëŒ€ 5ì¥ì˜ ì¹´ë“œë§Œ ì œì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤'); return prev; }
                  if(totalSpeed + card.speedCost > MAX_SPEED){ addLog('âš ï¸ ì†ë„ ì´ˆê³¼'); return prev; }
                  if(totalEnergy + card.actionCost > (BASE_PLAYER_ENERGY + etherSlots(player.etherPts))){ addLog('âš ï¸ í–‰ë™ë ¥ ë¶€ì¡±'); return prev; }
                  next = [...prev, { ...card, __uid: Math.random().toString(36).slice(2)}];
                }
                const combo = detectPokerCombo(next);
                const enhanced = applyPokerBonus(next, combo);
                setFixedOrder(sortCombinedOrderStablePF(enhanced, enemyPlan.actions||[]));
                return next;
              });
              return;
            }
            if(exists){ setSelected(selected.filter(s=>s.id!==card.id)); return; }
            if(selected.length >= MAX_SUBMIT_CARDS) return addLog('âš ï¸ ìµœëŒ€ 5ì¥ì˜ ì¹´ë“œë§Œ ì œì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤');
            if(totalSpeed + card.speedCost > MAX_SPEED) return addLog('âš ï¸ ì†ë„ ì´ˆê³¼');
            if(totalEnergy + card.actionCost > (BASE_PLAYER_ENERGY + etherSlots(player.etherPts))) return addLog('âš ï¸ í–‰ë™ë ¥ ë¶€ì¡±');
            setSelected([...selected, { ...card, __uid: Math.random().toString(36).slice(2)}]);
          };

          const moveUp = (i)=>{
            if(i===0) return;
            if(phase==='respond'){
              setSelected(prev=>{
                const n=[...prev]; [n[i-1],n[i]]=[n[i],n[i-1]];
                const combo = detectPokerCombo(n);
                const enhanced = applyPokerBonus(n, combo);
                setFixedOrder(sortCombinedOrderStablePF(enhanced, enemyPlan.actions||[]));
                return n;
              });
            } else {
              const n=[...selected]; [n[i-1],n[i]]=[n[i],n[i-1]]; setSelected(n);
            }
          };

          const moveDown = (i)=>{
            if(i===selected.length-1) return;
            if(phase==='respond'){
              setSelected(prev=>{
                const n=[...prev]; [n[i],n[i+1]]=[n[i+1],n[i]];
                const combo = detectPokerCombo(n);
                const enhanced = applyPokerBonus(n, combo);
                setFixedOrder(sortCombinedOrderStablePF(enhanced, enemyPlan.actions||[]));
                return n;
              });
            } else {
              const n=[...selected]; [n[i],n[i+1]]=[n[i+1],n[i]]; setSelected(n);
            }
          };

          const redrawHand = ()=>{
            if(!canRedraw) return addLog('ğŸ”’ ì´ë¯¸ ì´ë²ˆ í„´ ë¦¬ë“œë¡œìš° ì‚¬ìš©ë¨');
            setHand(CARDS.slice(0,8)); setSelected([]); setCanRedraw(false); addLog('ğŸ”„ ì†íŒ¨ ë¦¬ë“œë¡œìš° ì‚¬ìš©');
          };

          const startResolve = ()=>{
            if(phase!=='select') return;
            const actions = generateEnemyActions(enemy, enemyPlan.mode, etherSlots(enemy.etherPts));
            setEnemyPlan(prev=>({ ...prev, actions }));

            const pCombo = detectPokerCombo(selected);
            const enhancedSelected = applyPokerBonus(selected, pCombo);

            const q = sortCombinedOrderStablePF(enhancedSelected, actions);
            setFixedOrder(q);
            addLog(`ğŸ¤– ì  ì¹´ë“œ ê³µê°œ (ëŒ€ì‘ ë‹¨ê³„)`);
            setPhase('respond');
          };

          useEffect(()=>{
            if(phase==='respond' && enemyPlan.actions && enemyPlan.actions.length>0){
              const combo = detectPokerCombo(selected);
              const enhancedSelected = applyPokerBonus(selected, combo);
              const q = sortCombinedOrderStablePF(enhancedSelected, enemyPlan.actions);
              setFixedOrder(q);
            }
          }, [selected, phase, enemyPlan.actions]);

          const beginResolveFromRespond = ()=>{
            if(!fixedOrder) return addLog('ì˜¤ë¥˜: ê³ ì •ëœ ìˆœì„œê°€ ì—†ìŠµë‹ˆë‹¤');

            if(fixedOrder.length===0){
              addLog('âš ï¸ ì‹¤í–‰í•  í–‰ë™ì´ ì—†ìŠµë‹ˆë‹¤. ìµœì†Œ 1ì¥ ì´ìƒì„ ìœ ì§€í•˜ê±°ë‚˜ ì ì´ í–‰ë™ ê°€ëŠ¥í•œ ìƒíƒœì—¬ì•¼ í•©ë‹ˆë‹¤.');
              return;
            }

            const pComboNow = detectPokerCombo(selected);
            const eComboNow = detectPokerCombo(enemyPlan.actions);
            if(pComboNow && ETHER_GAIN_MAP[pComboNow.name]){
              const gain = ETHER_GAIN_MAP[pComboNow.name];
              setPlayer(p=>({ ...p, etherPts: addEther(p.etherPts, gain) }));
              addLog(`âœ´ï¸ ì—í…Œë¥´ +${gain} (í”Œë ˆì´ì–´ ì¡±ë³´: ${pComboNow.name})`);
            }
            if(eComboNow && ETHER_GAIN_MAP[eComboNow.name]){
              const gainE = ETHER_GAIN_MAP[eComboNow.name];
              setEnemy(e=>({ ...e, etherPts: addEther(e.etherPts, gainE) }));
              addLog(`â˜„ï¸ ì  ì—í…Œë¥´ +${gainE} (ì  ì¡±ë³´: ${eComboNow.name})`);
            }

            const enemyWillOD = shouldEnemyOverdrive(enemyPlan.mode, enemyPlan.actions, enemy.etherPts) && etherSlots(enemy.etherPts)>0;
            if((phase==='respond' || phase==='select') && willOverdrive && etherSlots(player.etherPts)>0){
              setPlayer(p=>({ ...p, etherPts: p.etherPts - ETHER_THRESHOLD, etherOverdriveActive:true }));
              addLog('âœ´ï¸ ì—í…Œë¥´ í­ì£¼ ë°œë™! (ì´ í„´ ì „ì²´ ìœ ì§€)');
            }
            if((phase==='respond' || phase==='select') && enemyWillOD){
              setEnemy(e=>({ ...e, etherPts: e.etherPts - ETHER_THRESHOLD, etherOverdriveActive:true }));
              addLog('â˜„ï¸ ì  ì—í…Œë¥´ í­ì£¼ ë°œë™!');
            }

            const newQ = fixedOrder.map(x=>({ actor:x.actor, card:x.card, sp:x.sp }));
            if(newQ.length===0){
              addLog('âš ï¸ í ìƒì„± ì‹¤íŒ¨: ì‹¤í–‰í•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤');
              return;
            }
            setQueue(newQ);
            setQIndex(0); setPhase('resolve'); addLog('â–¶ ì§„í–‰ ì‹œì‘');
          };

          const stepOnce = ()=>{
            if(qIndex>=queue.length) return;
            const a = queue[qIndex];

            // ì¹´ë“œ ì‚¬ìš© ì´í™íŠ¸ ì¶”ê°€
            if(a.actor === 'player') {
              setUsedCardIndices(prev => [...prev, qIndex]);
              setTimeout(() => {
                setUsedCardIndices(prev => prev.filter(i => i !== qIndex));
              }, 800);
            }

            const P = { ...player, def: player.def||false, block: player.block||0, counter: player.counter||0, vulnMult: player.vulnMult||1 };
            const E = { ...enemy,  def: enemy.def||false,  block: enemy.block||0,  counter: enemy.counter||0,  vulnMult: enemy.vulnMult||1 };
            const tempState = { player:P, enemy:E, log:[] };
            const {events} = applyAction(tempState, a.actor, a.card);

            setPlayer(prev=>({ ...prev, hp:P.hp, def:P.def, block:P.block, counter:P.counter, vulnMult:P.vulnMult||1 }));
            setEnemy(prev=>({  ...prev, hp:E.hp, def:E.def, block:E.block, counter:E.counter, vulnMult:E.vulnMult||1 }));
            setActionEvents(prev=>({ ...prev, [qIndex]: events }));
            events.forEach(ev=> addLog(ev.msg));
            setQIndex(prev=>prev+1);

            if(P.hp<=0){ setPostCombatOptions({ type:'defeat' }); setPhase('post'); return; }
            if(E.hp<=0){ setPostCombatOptions({ type:'victory' }); setPhase('post'); return; }
          };

          const finishTurn = (reason)=>{
            addLog(`í„´ ì¢…ë£Œ: ${reason||''}`);
            setPlayer(p=>({ ...p, block:0, def:false, counter:0, vulnMult:1, vulnTurns:0, etherOverdriveActive:false }));
            setEnemy(e=>({ ...e, block:0, def:false, counter:0, vulnMult:1, vulnTurns:0, etherOverdriveActive:false }));
            setSelected([]); setQueue([]); setQIndex(0); setFixedOrder(null); setUsedCardIndices([]);
            setPhase('select');
          };

          const downloadGameState = ()=>{
            const gameState = {
              player,
              enemyIndex,
              enemy,
              phase,
              hand,
              selected,
              canRedraw,
              enemyPlan,
              log,
              queue,
              qIndex,
              willOverdrive,
              timestamp: new Date().toISOString()
            };
            const dataStr = "const savedGameState = " + JSON.stringify(gameState, null, 2) + ";\n\n// ì´ íŒŒì¼ì„ ë¡œë“œí•˜ë ¤ë©´ ê²Œì„ì—ì„œ 'ë¶ˆëŸ¬ì˜¤ê¸°' ë²„íŠ¼ì„ ëˆ„ë¥´ê³  ì´ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.";
            const dataBlob = new Blob([dataStr], {type: 'application/javascript'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `game-save-${new Date().toISOString().replace(/[:.]/g, '-')}.js`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            addLog('ğŸ’¾ ê²Œì„ ì§„í–‰ìƒí™© ì €ì¥ë¨!');
          };

          const loadGameState = (event)=>{
            const file = event.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e)=>{
              try {
                const content = e.target.result;
                const stateMatch = content.match(/const savedGameState = ({[\s\S]*?});/);
                if(!stateMatch) {
                  addLog('âŒ ì˜ëª»ëœ ì €ì¥ íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤');
                  return;
                }
                const gameState = JSON.parse(stateMatch[1]);
                setPlayer(gameState.player);
                setEnemyIndex(gameState.enemyIndex);
                setEnemy(gameState.enemy);
                setPhase(gameState.phase);
                setHand(gameState.hand);
                setSelected(gameState.selected);
                setCanRedraw(gameState.canRedraw);
                setEnemyPlan(gameState.enemyPlan);
                setLog([...gameState.log, 'ğŸ“‚ ê²Œì„ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!']);
                setQueue(gameState.queue || []);
                setQIndex(gameState.qIndex || 0);
                setWillOverdrive(gameState.willOverdrive || false);
              } catch(err) {
                addLog('âŒ ì €ì¥ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: ' + err.message);
              }
            };
            reader.readAsText(file);
          };

          const runAll = ()=>{
            if(qIndex>=queue.length) return;
            let P = { ...player, def: player.def||false, block: player.block||0, counter: player.counter||0, vulnMult: player.vulnMult||1 };
            let E = { ...enemy,  def: enemy.def||false,  block: enemy.block||0,  counter: enemy.counter||0,  vulnMult: enemy.vulnMult||1 };
            const tempState = { player:P, enemy:E, log:[] };
            const newEvents = {};

            for(let i=qIndex;i<queue.length;i++){
              const a = queue[i];
              const {events} = applyAction(tempState, a.actor, a.card);
              newEvents[i] = events;
              events.forEach(ev=> addLog(ev.msg));
              if(P.hp<=0){
                setPlayer(prev=>({ ...prev, hp:P.hp, def:P.def, block:P.block, counter:P.counter, vulnMult:P.vulnMult||1 }));
                setEnemy(prev=>({  ...prev, hp:E.hp, def:E.def, block:E.block, counter:E.counter, vulnMult:E.vulnMult||1 }));
                setActionEvents(prev=>({ ...prev, ...newEvents }));
                setQIndex(i+1);
                setPostCombatOptions({ type:'defeat' }); setPhase('post');
                return;
              }
              if(E.hp<=0){
                setPlayer(prev=>({ ...prev, hp:P.hp, def:P.def, block:P.block, counter:P.counter, vulnMult:P.vulnMult||1 }));
                setEnemy(prev=>({  ...prev, hp:E.hp, def:E.def, block:E.block, counter:E.counter, vulnMult:E.vulnMult||1 }));
                setActionEvents(prev=>({ ...prev, ...newEvents }));
                setQIndex(i+1);
                setPostCombatOptions({ type:'victory' }); setPhase('post');
                return;
              }
            }
            setPlayer(prev=>({ ...prev, hp:P.hp, def:P.def, block:P.block, counter:P.counter, vulnMult:P.vulnMult||1 }));
            setEnemy(prev=>({  ...prev, hp:E.hp, def:E.def, block:E.block, counter:E.counter, vulnMult:E.vulnMult||1 }));
            setActionEvents(prev=>({ ...prev, ...newEvents }));
            setQIndex(queue.length);
          };

          const nextEnemy = ()=>{
            const next = enemyIndex + 1;
            if(next < ENEMIES.length){
              const heal = Math.floor(player.maxHp*0.3);
              setPlayer(p=>({ ...p, hp: Math.min(p.maxHp, p.hp+heal), energy: BASE_PLAYER_ENERGY, block:0, counter:0, vulnMult:1, vulnTurns:0, etherOverdriveActive:false }));
              const e = ENEMIES[next];
              setEnemy({ ...e, hp:e.hp, maxHp:e.hp, vulnMult:1, vulnTurns:0, block:0, counter:0, etherPts:0, etherOverdriveActive:false });
              setEnemyIndex(next); setSelected([]); setHand(CARDS.slice(0,8)); setEnemyPlan({ actions:[], mode: null }); setFixedOrder(null); setQueue([]); setQIndex(0); setCanRedraw(true); setPostCombatOptions(null); addLog(`â¡ï¸ ë‹¤ìŒ ëª¬ìŠ¤í„° ë“±ì¥: ${e.name} (ì†íŒ¨ ë¦¬ì…‹)`); setPhase('select');
            } else { addLog('ğŸ† ëª¨ë“  ì  ì²˜ì¹˜ - ê²Œì„ ë'); }
          };

          const removeSelectedAt = (i)=> setSelected(selected.filter((_,idx)=>idx!==i));

          const playerTimeline = useMemo(()=>{
            if(phase==='select'){
              let ps=0; return selected.map((c,idx)=>{ ps+=c.speedCost; return { actor:'player', card:c, sp:ps, idx }; });
            }
            if(phase==='respond' && fixedOrder) return fixedOrder.filter(x=>x.actor==='player');
            if(phase==='resolve') return queue.filter(x=>x.actor==='player');
            return [];
          }, [phase, selected, fixedOrder, queue]);

          const enemyTimeline = useMemo(()=>{
            if(phase==='select') return [];
            if(phase==='respond' && fixedOrder) return fixedOrder.filter(x=>x.actor==='enemy');
            if(phase==='resolve') return queue.filter(x=>x.actor==='enemy');
            return [];
          }, [phase, fixedOrder, queue]);

          if(!enemy) return <div className="text-white p-4">ë¡œë”©â€¦</div>;

          const handDisabled = (c)=> (
            selected.length >= MAX_SUBMIT_CARDS ||
            totalSpeed + c.speedCost > MAX_SPEED ||
            totalEnergy + c.actionCost > (BASE_PLAYER_ENERGY + etherSlots(player.etherPts))
          );

          return (
            <div className="w-full min-h-screen bg-gradient-to-br from-slate-950 via-purple-950 to-slate-950 pb-64">
              <TestBadge/>

              {/* ê²Œì„ ì½”ë“œ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ */}
              <div className="fixed top-4 right-4 z-50 flex gap-2">
                <button onClick={()=>{
                  const htmlContent = document.documentElement.outerHTML;
                  const scriptMatch = htmlContent.match(/<script type="text\/babel">([\s\S]*?)<\/script>/);
                  if(scriptMatch) {
                    const jsCode = scriptMatch[1];
                    const blob = new Blob([jsCode], {type: 'application/javascript'});
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'card-game.jsx';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                  }
                }} className="btn-enhanced flex items-center gap-2 bg-slate-700 hover:bg-slate-600">
                  ğŸ“¥ JS ì½”ë“œ ë‹¤ìš´ë¡œë“œ
                </button>
                <button onClick={()=>{
                  const htmlContent = document.documentElement.outerHTML;
                  const blob = new Blob([htmlContent], {type: 'text/html'});
                  const url = URL.createObjectURL(blob);
                  const link = document.createElement('a');
                  link.href = url;
                  link.download = 'card-game.html';
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                  URL.revokeObjectURL(url);
                }} className="btn-enhanced flex items-center gap-2 bg-slate-700 hover:bg-slate-600">
                  ğŸ“¥ HTML ë‹¤ìš´ë¡œë“œ
                </button>
              </div>

              {/* ìƒë‹¨ ë©”ì¸ ì˜ì—­ */}
              <div className="max-w-[1600px] mx-auto p-4">

                {/* Timeline */}
                <div className="panel-enhanced p-4 mb-6">
                  <div className="text-white font-bold mb-3 flex items-center gap-2">
                    <Clock size={20} className="text-cyan-400"/>
                    íƒ€ì„ë¼ì¸ (ëˆ„ì  ì†ë„) â€” {phase==='select'? 'ì„ íƒ' : (phase==='respond'? 'ëŒ€ì‘/ì˜ˆì¸¡' : (phase==='resolve' ? 'ì§„í–‰' : 'ê²°ê³¼'))} <span className="text-xs text-slate-300 ml-2">(ë™ë¥  ì‹œ í”Œë ˆì´ì–´ ìš°ì„ )</span>
                  </div>

                  <div className="relative h-36 bg-slate-900 rounded p-2 space-y-2">
                    {/* Player row */}
                    <div className="relative h-16 bg-slate-900 rounded">
                      {Array.from({length: MAX_SPEED + 1}).map((_,i)=>(
                        <div key={i} className="absolute top-0 bottom-0 border-l border-slate-700" style={{left:`${(i/MAX_SPEED)*100}%`}}>
                          {i%5===0 && <span className="absolute -top-6 -left-2 text-xs text-slate-400">{i}</span>}
                        </div>
                      ))}
                      {playerTimeline.map((a,idx)=>{
                        const Icon = a.card.icon || Sword;
                        const sameCount = playerTimeline.filter((q,i)=>i<idx && q.sp===a.sp).length;
                        const offset = sameCount*28;
                        const num = a.card.type==='attack' ? (a.card.damage*(a.card.hits||1)) : (a.card.block || 0);
                        return (
                          <div key={idx}
                               className={`absolute left-0 top-2 transform -translate-x-1/2 flex items-center gap-1 px-2 py-1 rounded-full ${a.actor==='player'? 'bg-blue-500 ring-2 ring-blue-300':''}`}
                               style={{left:`${(a.sp/MAX_SPEED)*100}%`, top:`${6+offset}px`, zIndex:20}}>
                            <Icon size={14} className="text-white"/>
                            <span className="text-white text-xs font-bold">{num>0?num:''}</span>
                          </div>
                        );
                      })}
                    </div>

                    <div className="h-px bg-slate-700" />

                    {/* Enemy row */}
                    <div className="relative h-16 bg-slate-900 rounded">
                      {Array.from({length: MAX_SPEED + 1}).map((_,i)=>(
                        <div key={i} className="absolute top-0 bottom-0 border-l border-slate-700" style={{left:`${(i/MAX_SPEED)*100}%`}} />
                      ))}
                      {enemyTimeline.map((a,idx)=>{
                        const Icon = a.card.icon || Shield;
                        const sameCount = enemyTimeline.filter((q,i)=>i<idx && q.sp===a.sp).length;
                        const offset = sameCount*28;
                        const num = a.card.type==='attack' ? (a.card.damage*(a.card.hits||1)) : (a.card.block || 0);
                        return (
                          <div key={idx}
                               className={`absolute left-0 top-2 transform -translate-x-1/2 flex items-center gap-1 px-2 py-1 rounded-full ${a.actor==='enemy'? 'bg-orange-500 ring-2 ring-orange-300':''}`}
                               style={{left:`${(a.sp/MAX_SPEED)*100}%`, top:`${6+offset}px`, zIndex:10}}>
                            <Icon size={14} className="text-white"/>
                            <span className="text-white text-xs font-bold">{num>0?num:''}</span>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>

                {/* ì˜ˆìƒ í”¼í•´ëŸ‰ - íƒ€ì„ë¼ì¸ ì¤‘ì•™ í•˜ë‹¨ */}
                {(phase==='respond' || phase==='select') && (
                  <div className="flex justify-center mt-4">
                    <ExpectedDamagePreview player={player} enemy={enemy} fixedOrder={fixedOrder||playerTimeline} willOverdrive={willOverdrive} enemyMode={enemyPlan.mode} enemyActions={enemyPlan.actions}/>
                  </div>
                )}

                {/* Battle Arena - íƒ€ì„ë¼ì¸ê³¼ ê°™ì€ ë„ˆë¹„ */}
                <div className="battle-arena p-8 mb-6">
                      <div className="flex justify-between items-center">
                        {/* Player Ether Bar */}
                        <div className="flex flex-col items-center">
                          <div className="text-cyan-400 font-black text-sm mb-2">ì—í…Œë¥´</div>
                          <div className="ether-bar-vertical player">
                            <div className="ether-fill-vertical player" style={{height: `${Math.min((player.etherPts / 800) * 100, 100)}%`}}></div>
                          </div>
                          <div className="text-cyan-400 font-bold text-xs mt-2">{player.etherPts}pt</div>
                          <div className="text-cyan-300 text-xs">Ã—{etherSlots(player.etherPts)}</div>
                        </div>

                        {/* Player Side */}
                        <div className="flex items-center gap-6">
                          <div className="character-display">ğŸ§™â€â™‚ï¸</div>
                          <div>
                            <div className="text-cyan-400 font-black text-2xl mb-2">í”Œë ˆì´ì–´</div>
                            <div className="hp-bar-enhanced mb-3" style={{width: '300px'}}>
                              <div className="hp-fill" style={{width: `${(player.hp/player.maxHp)*100}%`}}></div>
                            </div>
                            <div className="text-white font-black text-xl mb-2">
                              â¤ï¸ {player.hp}/{player.maxHp}
                            </div>
                            <div className="flex gap-2 flex-wrap">
                              {player.block>0 && <span className="px-3 py-1 rounded-full bg-blue-700 text-white text-sm font-bold">ğŸ›¡ï¸ {player.block}</span>}
                              {player.vulnMult>1 && <span className="px-3 py-1 rounded-full bg-red-700 text-white text-sm font-bold">ì·¨ì•½ Ã—{player.vulnMult.toFixed(1)}</span>}
                              {player.etherOverdriveActive && <span className="px-3 py-1 rounded-full bg-cyan-600 text-white text-sm font-bold animate-pulse">âš¡í­ì£¼</span>}
                            </div>
                            <button onClick={()=> (phase==='select' || phase==='respond') && setWillOverdrive(v=>!v)}
                                    disabled={!(phase==='select'||phase==='respond') || etherSlots(player.etherPts)<=0}
                                    className={`mt-3 btn-enhanced ${willOverdrive? 'btn-primary':''} text-sm`}>
                              âš¡ ì—í…Œë¥´ í­ì£¼ {willOverdrive?'ON':'OFF'}
                            </button>
                          </div>
                        </div>

                        {/* VS */}
                        <div className="text-center">
                          {/* Phase Indicator - ëŒ€ì‘/ì§„í–‰ ë‹¨ê³„ í‘œì‹œ */}
                          {phase==='respond' && (
                            <div className="bg-slate-800 rounded-lg px-6 py-3 mb-4 mx-auto" style={{width: '400px', maxWidth: '90vw'}}>
                              <div className="text-white font-bold text-lg text-center">ğŸ” ëŒ€ì‘ ë‹¨ê³„</div>
                              <div className="text-slate-300 text-xs text-center mt-1">ìˆœì„œë¥¼ ì¡°ì •í•˜ê±°ë‚˜ ì—í…Œë¥´ í­ì£¼ë¥¼ í† ê¸€í•œ ë’¤ ì§„í–‰í•˜ì„¸ìš”</div>
                            </div>
                          )}
                          {phase==='resolve' && (
                            <div className="bg-slate-800 rounded-lg px-6 py-3 mb-4 mx-auto" style={{width: '400px', maxWidth: '90vw'}}>
                              <div className="text-white font-bold text-lg text-center">â–¶ ì§„í–‰ ì¤‘ ({qIndex}/{queue?.length || 0})</div>
                            </div>
                          )}

                          <div className="text-8xl mb-4">âš”ï¸</div>
                          <div className="text-slate-400 font-black mb-3">VS</div>

                          {/* Log - VS í•˜ë‹¨ */}
                          <div className="bg-slate-800/90 rounded-lg px-4 py-2 mt-4" style={{width: '500px', maxWidth: '90vw'}}>
                            <div className="flex items-center gap-2">
                              <div className="text-white font-bold text-xs whitespace-nowrap">ğŸ“œ</div>
                              <div className="flex-1 overflow-y-auto text-xs text-slate-300" style={{maxHeight: '60px'}}>
                                {log.slice(-6).map((l,i)=>(<div key={i} className="mb-1">{l}</div>))}
                                <div ref={logEndRef}></div>
                              </div>
                            </div>
                          </div>
                        </div>

                        {/* Enemy Side */}
                        <div className="flex items-center gap-6">
                          <div className="text-right">
                            {enemyPlan.mode && (
                              <div className="text-amber-400 font-bold text-sm mb-1">
                                {enemyPlan.mode.name}
                              </div>
                            )}
                            <div className="text-orange-400 font-black text-2xl mb-2">{enemy.name}</div>
                            <div className="hp-bar-enhanced mb-3" style={{width: '300px'}}>
                              <div className="hp-fill" style={{width: `${(enemy.hp/enemy.maxHp)*100}%`}}></div>
                            </div>
                            <div className="text-white font-black text-xl mb-2">
                              â¤ï¸ {enemy.hp}/{enemy.maxHp}
                            </div>
                            <div className="flex gap-2 flex-wrap justify-end">
                              {enemy.block>0 && <span className="px-3 py-1 rounded-full bg-blue-700 text-white text-sm font-bold">ğŸ›¡ï¸ {enemy.block}</span>}
                              {enemy.vulnMult>1 && <span className="px-3 py-1 rounded-full bg-red-700 text-white text-sm font-bold">ì·¨ì•½ Ã—{enemy.vulnMult.toFixed(1)}</span>}
                              {enemy.etherOverdriveActive && <span className="px-3 py-1 rounded-full bg-fuchsia-600 text-white text-sm font-bold animate-pulse">âš¡í­ì£¼</span>}
                            </div>
                            <div className="text-slate-400 text-sm mt-2">ì  {enemyIndex+1}/{ENEMIES.length}</div>
                          </div>
                          <div className="character-display">ğŸ‰</div>
                        </div>

                        {/* Enemy Ether Bar */}
                        <div className="flex flex-col items-center">
                          <div className="text-fuchsia-400 font-black text-sm mb-2">ì—í…Œë¥´</div>
                          <div className="ether-bar-vertical enemy">
                            <div className="ether-fill-vertical enemy" style={{height: `${Math.min((enemy.etherPts / 800) * 100, 100)}%`}}></div>
                          </div>
                          <div className="text-fuchsia-400 font-bold text-xs mt-2">{enemy.etherPts}pt</div>
                          <div className="text-fuchsia-300 text-xs">Ã—{etherSlots(enemy.etherPts)}</div>
                        </div>
                      </div>
                </div>
              </div>

              {/* ì§„í–‰ ë‹¨ê³„ - ì œì¶œëœ ì¹´ë“œ í‘œì‹œ */}
              {phase==='resolve' && queue.length > 0 && (
                <div className="fixed bottom-0 left-0 right-0 submitted-cards-area z-100">
                  <div className="flex items-center justify-between mb-4 max-w-[1600px] mx-auto px-4">
                    <div className="text-white font-black text-2xl">âš”ï¸ ì „íˆ¬ ì§„í–‰ ì¤‘... ({qIndex}/{queue.length})</div>
                    <div className="flex gap-2">
                      <button onClick={stepOnce} disabled={qIndex>=queue.length} className="btn-enhanced flex items-center gap-2">
                        <StepForward size={18}/> í•œ ë‹¨ê³„
                      </button>
                      <button onClick={runAll} disabled={qIndex>=queue.length} className="btn-enhanced btn-primary">
                        ì „ë¶€ ì‹¤í–‰
                      </button>
                      {qIndex >= queue.length && (
                        <button onClick={()=>finishTurn('ìˆ˜ë™ í„´ ì¢…ë£Œ')} className="btn-enhanced flex items-center gap-2">
                          â­ï¸ í„´ ì¢…ë£Œ
                        </button>
                      )}
                      {enemy && enemy.hp <= 0 && (
                        <button onClick={nextEnemy} disabled={enemyIndex >= ENEMIES.length - 1} className="btn-enhanced flex items-center gap-2">
                          â¡ï¸ ë‹¤ìŒ ì 
                        </button>
                      )}
                      {player && player.hp <= 0 && (
                        <button onClick={()=>window.location.reload()} className="btn-enhanced flex items-center gap-2">
                          ğŸ”„ ì¬ì‹œì‘
                        </button>
                      )}
                    </div>
                  </div>

                  <div className="hand-cards">
                    {queue.filter(a => a.actor === 'player').map((a,i)=>{
                      const Icon = a.card.icon;
                      const globalIndex = queue.findIndex(q => q === a);
                      const isUsed = usedCardIndices.includes(globalIndex);
                      const isPast = globalIndex < qIndex;
                      return (
                        <div key={`resolve-${globalIndex}`}
                             className={`game-card-large ${a.card.type==='attack' ? 'attack' : 'defense'} ${isUsed ? 'card-used' : ''} ${isPast ? 'opacity-30' : ''}`}>
                          <div className="card-cost-corner">{a.card.actionCost}</div>
                          <div className="card-header">
                            <div className="text-white font-black text-sm">{a.card.name}</div>
                          </div>
                          <div className="card-icon-area">
                            <Icon size={60} className="text-white opacity-80"/>
                          </div>
                          <div className="card-footer">
                            <div className="flex items-center justify-center gap-2 text-white text-sm font-bold">
                              {a.card.damage && <span className="text-red-300">âš”ï¸{a.card.damage}{a.card.hits?`Ã—${a.card.hits}`:''}</span>}
                              {a.card.block && <span className="text-blue-300">ğŸ›¡ï¸{a.card.block}</span>}
                              {a.card.counter!==undefined && <span className="text-purple-300">âš¡{a.card.counter}</span>}
                            </div>
                            <div className="text-cyan-300 text-xs mt-1">â±ï¸{a.card.speedCost}</div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {/* ëŒ€ì‘ ë‹¨ê³„ - ì œì¶œëœ ì¹´ë“œ í‘œì‹œ */}
              {phase==='respond' && selected.length > 0 && (
                <div className="fixed bottom-0 left-0 right-0 submitted-cards-area z-100">
                  <div className="flex items-center justify-between mb-4 max-w-[1600px] mx-auto px-4">
                    <div className="text-white font-black text-2xl">ğŸ“‹ ì œì¶œëœ ì¹´ë“œ</div>

                    {/* ì¡°í•© í‘œì‹œ - ì¤‘ì•™ */}
                    {currentCombo && (
                      <div className="combo-display">
                        â­ {currentCombo.name} â­
                      </div>
                    )}

                    <div className="flex gap-2">
                      <button onClick={beginResolveFromRespond} className="btn-enhanced btn-success flex items-center gap-2">
                        <Play size={20}/> ì§„í–‰ ì‹œì‘
                      </button>
                      {enemy && enemy.hp <= 0 && (
                        <button onClick={nextEnemy} disabled={enemyIndex >= ENEMIES.length - 1} className="btn-enhanced flex items-center gap-2">
                          â¡ï¸ ë‹¤ìŒ ì 
                        </button>
                      )}
                    </div>
                  </div>

                  <div className="hand-cards">
                    {selected.map((c,i)=>{
                      const Icon=c.icon;
                      return (
                        <div key={`${c.__uid}-${i}`} className="relative">
                          <div className={`game-card-large ${c.type==='attack' ? 'attack' : 'defense'}`}>
                            <div className="card-cost-corner">{c.actionCost}</div>
                            <div className="selection-number">{i + 1}</div>
                            <div className="card-header">
                              <div className="text-white font-black text-sm">{c.name}</div>
                            </div>
                            <div className="card-icon-area">
                              <Icon size={60} className="text-white opacity-80"/>
                            </div>
                            <div className="card-footer">
                              <div className="flex items-center justify-center gap-2 text-white text-sm font-bold">
                                {c.damage && <span className="text-red-300">âš”ï¸{c.damage}{c.hits?`Ã—${c.hits}`:''}</span>}
                                {c.block && <span className="text-blue-300">ğŸ›¡ï¸{c.block}</span>}
                                {c.counter!==undefined && <span className="text-purple-300">âš¡{c.counter}</span>}
                              </div>
                              <div className="text-cyan-300 text-xs mt-1">â±ï¸{c.speedCost}</div>
                            </div>
                          </div>
                          <div className="flex gap-2 justify-center mt-2">
                            <button onClick={()=>moveUp(i)} disabled={i===0} className="card-move-btn">
                              â†
                            </button>
                            <button onClick={()=>moveDown(i)} disabled={i===selected.length-1} className="card-move-btn">
                              â†’
                            </button>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {/* í•˜ë‹¨ ê³ ì • ì†íŒ¨ ì˜ì—­ */}
              {(phase==='select' || (enemy && enemy.hp <= 0) || (player && player.hp <= 0)) && (
                <div className="hand-area">
                  <div className="flex items-center justify-between mb-4 max-w-[1600px] mx-auto px-4">
                    <div className="flex items-center gap-4">
                      {phase==='select' && (
                        <>
                          <div className="energy-orb-large">
                            {(BASE_PLAYER_ENERGY + etherSlots(player.etherPts)) - totalEnergy}
                          </div>
                          <div>
                            <div className="text-white font-black text-xl">ì†íŒ¨</div>
                            <div className="text-slate-400 text-sm">
                              ì†ë„: {totalSpeed}/{MAX_SPEED} | ì„ íƒ: {selected.length}/{MAX_SUBMIT_CARDS}
                            </div>
                          </div>
                        </>
                      )}
                      {enemy && enemy.hp <= 0 && (
                        <div className="text-emerald-300 font-black text-2xl">ğŸ† ì  ì²˜ì¹˜!</div>
                      )}
                      {player && player.hp <= 0 && (
                        <div className="text-rose-300 font-black text-2xl">ğŸ’€ íŒ¨ë°°...</div>
                      )}
                    </div>

                    {/* ì¡°í•© í‘œì‹œ - ì¤‘ì•™ */}
                    {phase==='select' && currentCombo && (
                      <div className="combo-display">
                        â­ {currentCombo.name} â­
                      </div>
                    )}

                    <div className="flex gap-3">
                      {phase==='select' && (
                        <>
                          <button onClick={redrawHand} disabled={!canRedraw} className="btn-enhanced flex items-center gap-2">
                            <RefreshCw size={18}/> ë¦¬ë“œë¡œìš°
                          </button>
                          <button onClick={startResolve} disabled={selected.length===0} className="btn-enhanced btn-primary flex items-center gap-2">
                            <Play size={20}/> ì œì¶œ
                          </button>
                        </>
                      )}
                      {enemy && enemy.hp <= 0 && (
                        <button onClick={nextEnemy} disabled={enemyIndex >= ENEMIES.length - 1} className="btn-enhanced flex items-center gap-2">
                          â¡ï¸ ë‹¤ìŒ ì 
                        </button>
                      )}
                      {player && player.hp <= 0 && (
                        <button onClick={()=>window.location.reload()} className="btn-enhanced flex items-center gap-2">
                          ğŸ”„ ì¬ì‹œì‘
                        </button>
                      )}
                    </div>
                  </div>

                  {phase==='select' && (
                    <div className="hand-cards">
                      {hand.map((c,idx)=>{
                        const Icon=c.icon;
                        const selIndex = selected.findIndex(s=>s.id===c.id);
                        const sel = selIndex !== -1;
                        const disabled = handDisabled(c) && !sel;
                        return (
                          <button key={c.id+idx} onClick={()=>toggle(c)} disabled={disabled}
                                  className={`game-card-large ${c.type==='attack' ? 'attack' : 'defense'} ${sel ? 'selected' : ''} ${disabled ? 'disabled' : ''}`}>
                            <div className="card-cost-corner">{c.actionCost}</div>
                            {sel && <div className="selection-number">{selIndex + 1}</div>}
                            <div className="card-header">
                              <div className="text-white font-black text-sm">{c.name}</div>
                            </div>
                            <div className="card-icon-area">
                              <Icon size={60} className="text-white opacity-80"/>
                            </div>
                            <div className="card-footer">
                              <div className="flex items-center justify-center gap-2 text-white text-sm font-bold">
                                {c.damage && <span className="text-red-300">âš”ï¸{c.damage}{c.hits?`Ã—${c.hits}`:''}</span>}
                                {c.block && <span className="text-blue-300">ğŸ›¡ï¸{c.block}</span>}
                                {c.counter!==undefined && <span className="text-purple-300">âš¡{c.counter}</span>}
                              </div>
                              <div className="text-cyan-300 text-xs mt-1">â±ï¸{c.speedCost}</div>
                            </div>
                          </button>
                        );
                      })}
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        }

        ReactDOM.render(<Game />, document.getElementById('root'));
    </script>
</body>
</html>
