<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TERMINUS</title>
    <style>
      :root {
        --bg0: #020409;
        --panel: rgba(2, 4, 9, 0.62);
        --border: rgba(148, 163, 184, 0.22);
        --muted: #94a3b8;
        --text: #e2e8f0;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
        background: radial-gradient(circle at 20% 0%, rgba(34, 64, 122, 0.45), rgba(2, 4, 9, 0.96));
        color: var(--text);
        overflow: hidden;
      }

      .page {
        position: fixed;
        inset: 0;
        display: grid;
        grid-template-columns: 360px 1fr;
      }

      .panel {
        border-right: 1px solid var(--border);
        background: var(--panel);
        padding: 16px 14px;
        overflow: auto;
      }

      .main {
        position: relative;
      }
      #graph {
        position: absolute;
        inset: 0;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .row-between {
        display: flex;
        gap: 10px;
        align-items: baseline;
        justify-content: space-between;
      }
      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(15, 23, 42, 0.6);
        font-size: 12px;
        color: #cbd5e1;
      }

      .tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .tab {
        padding: 7px 10px;
        font-size: 12px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.35);
        color: var(--text);
        cursor: pointer;
        white-space: nowrap;
      }
      .tab.active {
        border-color: rgba(59, 130, 246, 0.6);
        background: rgba(59, 130, 246, 0.18);
      }

      #altView {
        position: absolute;
        inset: 0;
        overflow: auto;
        padding: 16px;
        display: none;
      }
      .cardGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .card {
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.35);
        padding: 12px 12px;
      }
      .cardTitle {
        font-size: 12px;
        color: #cbd5e1;
        font-weight: 900;
      }
      .cardValue {
        font-size: 22px;
        font-weight: 950;
        margin-top: 6px;
      }
      .mini {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
        line-height: 1.35;
      }

      label {
        font-size: 12px;
        color: #cbd5e1;
      }
      input[type="text"],
      select {
        width: 100%;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(15, 23, 42, 0.55);
        color: var(--text);
        outline: none;
      }

      .checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #cbd5e1;
      }

      .hint {
        margin-top: 10px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }

      hr {
        border: none;
        border-top: 1px solid rgba(148, 163, 184, 0.18);
        margin: 14px 0;
      }

      button {
        padding: 8px 10px;
        font-size: 12px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.45);
        color: var(--text);
        cursor: pointer;
      }
      button:hover {
        background: rgba(30, 41, 59, 0.55);
      }
      button:active {
        transform: translateY(1px);
      }

      .list {
        margin-top: 8px;
        max-height: 240px;
        overflow: auto;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.35);
      }

      .list button {
        width: 100%;
        text-align: left;
        border: none;
        border-bottom: 1px solid rgba(148, 163, 184, 0.12);
        border-radius: 0;
        background: transparent;
        padding: 8px 10px;
      }
      .list button.selected {
        background: rgba(59, 130, 246, 0.18);
      }
      .list button:last-child {
        border-bottom: none;
      }
    </style>
  </head>
  <body>
    <div class="page">
      <aside class="panel">
        <div class="row-between">
          <div>
            <div style="font-size: 16px; font-weight: 900;">테르미누스</div>
            <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">Notion DB → 그래프</div>
          </div>
          <div class="row" style="gap: 8px;">
            <button id="btn-export" type="button" title="terminus-graph.json 다시 불러오기">갱신</button>
            <button id="btn-fit" type="button">맞춤</button>
          </div>
        </div>

        <div class="row" style="flex-wrap: wrap; margin-top: 12px;">
          <span class="badge">view=terminus</span>
          <span id="badge-export" class="badge" style="display: none;"></span>
        </div>

        <div id="modeTabs" class="tabs" style="margin-top: 12px;">
          <button class="tab active" type="button" data-mode="territory">영역</button>
          <button class="tab" type="button" data-mode="layer">레이어</button>
          <button class="tab" type="button" data-mode="pov">POV</button>
          <button class="tab" type="button" data-mode="state">상태전이</button>
          <button class="tab" type="button" data-mode="timeline">타임라인</button>
          <button class="tab" type="button" data-mode="ui">UI</button>
        </div>

        <div id="modeHint" class="hint" style="margin-top: 10px;"></div>

        <div id="control-layer" style="margin-top: 10px; display: none;">
          <div style="font-size: 12px; color: #cbd5e1; margin-bottom: 6px;">레이어</div>
          <select id="layer">
            <option value="ALL">전체</option>
            <option value="CORE">CORE</option>
            <option value="SYSTEM">SYSTEM</option>
            <option value="NARRATIVE">NARRATIVE</option>
            <option value="PLAYER">PLAYER</option>
            <option value="UNSORTED">미분류</option>
          </select>
        </div>

        <div id="control-pov" style="margin-top: 10px; display: none;">
          <div style="font-size: 12px; color: #cbd5e1; margin-bottom: 6px;">관측자(POV)</div>
          <select id="pov">
            <option value="PLAYER">PLAYER</option>
            <option value="NPC">NPC</option>
            <option value="종언자">종언자</option>
            <option value="CORE">CORE</option>
            <option value="ALL">전체</option>
          </select>
        </div>

        <div id="control-status" style="margin-top: 10px; display: none;">
          <div style="font-size: 12px; color: #cbd5e1; margin-bottom: 6px;">상태</div>
          <select id="status">
            <option value="ALL">전체</option>
            <option value="초안">초안</option>
            <option value="정리중">정리중</option>
            <option value="확정">확정</option>
            <option value="미지정">미지정</option>
          </select>
        </div>

        <div id="stats" class="hint" style="margin-top: 12px;"></div>

        <div style="margin-top: 14px;">
          <label for="q">검색(제목)</label>
          <div style="margin-top: 6px;">
            <input id="q" type="text" placeholder="예: 초법, 설정, 캐릭터…" />
          </div>
        </div>

        <div class="grid2" style="margin-top: 12px;">
          <div>
            <div style="font-size: 12px; color: #cbd5e1; margin-bottom: 6px;">도메인</div>
            <select id="domain">
              <option value="ALL">전체</option>
              <option value="세계관">세계관</option>
              <option value="소설">소설</option>
              <option value="게임">게임</option>
            </select>
          </div>
          <div>
            <div style="font-size: 12px; color: #cbd5e1; margin-bottom: 6px;">대분류</div>
            <select id="category">
              <option value="ALL">전체</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top: 12px; gap: 14px;">
          <label class="checkbox"><input id="showItems" type="checkbox" /> 항목 표시</label>
          <label class="checkbox"><input id="showRelations" type="checkbox" checked /> 관련 노드(점선)</label>
        </div>

        <div id="itemControls" style="margin-top: 10px; display: none;">
          <div style="font-size: 12px; color: #cbd5e1; margin-bottom: 6px;">항목 최대 표시</div>
          <div class="row">
            <select id="itemLimit">
              <option value="100">100</option>
              <option value="200">200</option>
              <option value="250" selected>250</option>
              <option value="400">400</option>
              <option value="600">600</option>
            </select>
            <button id="btn-collapse" type="button" style="display: none; white-space: nowrap;">펼침 닫기</button>
          </div>
          <div id="itemStats" class="hint" style="margin-top: 6px; display: none;"></div>
        </div>

        <div style="margin-top: 10px;">
          <label class="checkbox"><input id="mindmap" type="checkbox" checked /> 마인드맵 정렬(안정)</label>
        </div>

        <hr />

        <div>
          <div style="font-size: 12px; color: #cbd5e1; font-weight: 800;">선택 노드</div>
          <div id="selectedEmpty" class="hint">노드를 클릭하면 상세가 나옵니다.</div>
          <div id="selectedBox" style="display: none; margin-top: 8px;"></div>
        </div>

        <div id="itemListBox" style="display: none; margin-top: 14px;">
          <div class="row-between">
            <div style="font-size: 12px; color: #cbd5e1; font-weight: 800;">항목 목록</div>
            <div id="itemListCount" style="font-size: 12px; color: var(--muted);"></div>
          </div>
          <div id="itemList" class="list"></div>
          <div id="itemListHint" class="hint" style="display: none;"></div>
        </div>

        <hr />

        <div class="hint">
          - 항목이 겹치면 <b>검색/필터</b>로 줄이거나, 카테고리 노드 클릭(펼침)으로 좁히세요.<br />
          - 관련 노드(점선)는 선택한 노드 주변만 표시합니다.
        </div>
      </aside>

      <main class="main">
        <div id="graph"></div>
        <div id="altView"></div>
      </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/force-graph@1.49.0/dist/force-graph.min.js"></script>

    <script>
      const DEFAULT_WARMUP_TICKS = 40;
      const DEFAULT_COOLDOWN_TICKS = 220;
      const ITEM_LIST_LIMIT = 120;

      const MODES = [
        { id: "territory", label: "영역" },
        { id: "layer", label: "레이어" },
        { id: "pov", label: "POV" },
        { id: "state", label: "상태전이" },
        { id: "timeline", label: "타임라인" },
        { id: "ui", label: "UI" },
      ];

      const MODE_HINTS = {
        territory: "도메인/대분류 기반 '영역 지도'입니다. 항목은 검색/필터로 줄인 뒤 표시하세요.",
        layer: "CORE/SYSTEM/NARRATIVE/PLAYER 레이어로 정렬합니다. (노션 '레이어' 속성이 있으면 우선 사용)",
        pov: "관측자(POV)별로 '무엇까지 보이는가'를 보여줍니다. (기본 규칙: 레이어 기반)",
        state: "작업 상태(초안→정리중→확정)를 상태 전이처럼 봅니다. (노션 '상태' 사용)",
        timeline: "시간(노션 '시간' date 또는 '시점') 기준으로 묶어서 봅니다.",
        ui: "그래프 대신 대시보드/목록으로 빠르게 탐색합니다.",
      };

      const elGraph = document.getElementById("graph");
      const elStats = document.getElementById("stats");
      const elExport = document.getElementById("badge-export");
      const elQ = document.getElementById("q");
      const elDomain = document.getElementById("domain");
      const elCategory = document.getElementById("category");
      const elShowItems = document.getElementById("showItems");
      const elShowRelations = document.getElementById("showRelations");
      const elMindmap = document.getElementById("mindmap");
      const elItemControls = document.getElementById("itemControls");
      const elItemLimit = document.getElementById("itemLimit");
      const elItemStats = document.getElementById("itemStats");
      const elBtnCollapse = document.getElementById("btn-collapse");
      const elAltView = document.getElementById("altView");

      const elModeTabs = document.getElementById("modeTabs");
      const elModeHint = document.getElementById("modeHint");
      const elControlLayer = document.getElementById("control-layer");
      const elLayer = document.getElementById("layer");
      const elControlPov = document.getElementById("control-pov");
      const elPov = document.getElementById("pov");
      const elControlStatus = document.getElementById("control-status");
      const elStatus = document.getElementById("status");

      const elSelectedEmpty = document.getElementById("selectedEmpty");
      const elSelectedBox = document.getElementById("selectedBox");
      const elItemListBox = document.getElementById("itemListBox");
      const elItemList = document.getElementById("itemList");
      const elItemListCount = document.getElementById("itemListCount");
      const elItemListHint = document.getElementById("itemListHint");

      const state = {
        raw: null,
        mode: "territory",
        query: "",
        domainFilter: "ALL",
        categoryFilter: "ALL",
        layerFilter: "ALL",
        povFilter: "PLAYER",
        statusFilter: "ALL",
        showItems: false,
        showRelations: true,
        mindmapLayout: true,
        itemLimit: 250,
        expandedCategoryScope: null,
        selectedNodeId: null,
        hoveredNodeId: null,
        userInteracted: false,
        autoFitDone: false,
      };

      const nodeCache = new Map();

      function includesCI(haystack, needle) {
        return String(haystack || "").toLowerCase().includes(String(needle || "").toLowerCase());
      }

      function toSafeIdPart(value) {
        return String(value || "")
          .trim()
          .replace(/\s+/g, "_")
          .replace(/[^0-9a-zA-Z가-힣_]+/g, "_")
          .slice(0, 80);
      }

      function makeId(prefix, ...parts) {
        return [prefix, ...parts.map(toSafeIdPart)].join("__");
      }

      const LAYERS = ["CORE", "SYSTEM", "NARRATIVE", "PLAYER", "UNSORTED"];
      const LAYER_LABEL = {
        CORE: "CORE",
        SYSTEM: "SYSTEM",
        NARRATIVE: "NARRATIVE",
        PLAYER: "PLAYER",
        UNSORTED: "미분류",
      };

      function normalizeLayer(value) {
        const raw = String(value || "").trim().toUpperCase();
        if (!raw) return null;
        if (raw === "CORE" || raw === "SYSTEM" || raw === "NARRATIVE" || raw === "PLAYER") return raw;
        if (raw === "UNSORTED") return "UNSORTED";
        if (raw === "코어") return "CORE";
        if (raw === "시스템") return "SYSTEM";
        if (raw === "서사" || raw === "내러티브") return "NARRATIVE";
        if (raw === "플레이어") return "PLAYER";
        return null;
      }

      function inferLayerFromItem(item) {
        const direct = normalizeLayer(item && item.layer);
        if (direct) return direct;

        const category = String(item && item.category ? item.category : "");
        const tags = new Set(Array.isArray(item && item.tags) ? item.tags : []);

        if (tags.has("플레이어") || tags.has("노출") || tags.has("공개")) return "PLAYER";
        if (category === "시스템(게임)") return "SYSTEM";
        if (category === "플롯/에피소드") return "NARRATIVE";
        if (category === "메타") return "CORE";

        if (tags.has("시스템") || tags.has("룰") || tags.has("밸런스")) return "SYSTEM";
        if (tags.has("스토리") || tags.has("플롯") || tags.has("에피소드") || tags.has("서사")) return "NARRATIVE";

        return "UNSORTED";
      }

      const PERSPECTIVES = ["PLAYER", "NPC", "종언자", "CORE"];
      const PERSPECTIVE_LEVEL = { PLAYER: 0, NPC: 1, 종언자: 2, CORE: 3 };
      const LAYER_LEVEL = { PLAYER: 0, NARRATIVE: 1, SYSTEM: 2, CORE: 3, UNSORTED: 3 };

      function normalizePerspective(value) {
        const v = String(value || "").trim();
        if (!v) return null;
        if (v === "PLAYER" || v === "NPC" || v === "종언자" || v === "CORE") return v;
        const upper = v.toUpperCase();
        if (upper === "PLAYER") return "PLAYER";
        if (upper === "NPC") return "NPC";
        if (v === "플레이어") return "PLAYER";
        return null;
      }

      function pickPrimaryVisibility(item) {
        const raw = Array.isArray(item && item.visibility) ? item.visibility : [];
        const normalized = raw.map(normalizePerspective).filter(Boolean);
        if (normalized.length === 0) return null;
        for (const p of PERSPECTIVES) {
          if (normalized.includes(p)) return p;
        }
        return normalized[0] || null;
      }

      function isVisibleToPerspective(item, pov) {
        const p = normalizePerspective(pov);
        if (!p) return false;

        const raw = Array.isArray(item && item.visibility) ? item.visibility : [];
        const normalized = raw.map(normalizePerspective).filter(Boolean);
        if (normalized.length > 0) return normalized.includes(p);

        const layer = inferLayerFromItem(item);
        return (PERSPECTIVE_LEVEL[p] || 0) >= (LAYER_LEVEL[layer] || 0);
      }

      function getRootNode(raw) {
        const hit = (raw && raw.nodes ? raw.nodes : []).find((n) => n.type === "root");
        return hit ? upsertCachedNode(hit) : upsertCachedNode({ id: "__terminus_root__", type: "root", label: "테르미누스" });
      }

      function getEndpointId(value) {
        if (!value) return null;
        if (typeof value === "string" || typeof value === "number") return String(value);
        if (typeof value === "object" && value.id != null) return String(value.id);
        return null;
      }

      function linkKey(s, t, type) {
        if (!s || !t) return "";
        if (type === "relation") {
          const a = [String(s), String(t)].sort();
          return a[0] + "|" + a[1] + "|" + type;
        }
        return String(s) + "|" + String(t) + "|" + type;
      }

      function getNodeSize(node) {
        if (node.type === "root") return 10;
        if (node.type === "domain") return 8;
        if (node.type === "layer") return 8;
        if (node.type === "pov") return 8;
        if (node.type === "state") return 8;
        if (node.type === "time") return 7;
        if (node.type === "category") return 6;
        return 3;
      }

      function getNodeBaseColor(node) {
        if (node.type === "root") return "#f8fafc";
        if (node.type === "domain") {
          if (node.domain === "세계관") return "#60a5fa";
          if (node.domain === "소설") return "#f472b6";
          if (node.domain === "게임") return "#34d399";
          return "#93c5fd";
        }
        if (node.type === "layer") {
          const l = normalizeLayer(node.layer || node.label);
          if (l === "CORE") return "#cbd5e1";
          if (l === "SYSTEM") return "#34d399";
          if (l === "NARRATIVE") return "#fde047";
          if (l === "PLAYER") return "#60a5fa";
          return "#94a3b8";
        }
        if (node.type === "pov") {
          const p = normalizePerspective(node.pov || node.label);
          if (p === "PLAYER") return "#60a5fa";
          if (p === "NPC") return "#fde047";
          if (p === "종언자") return "#a78bfa";
          if (p === "CORE") return "#cbd5e1";
          return "#94a3b8";
        }
        if (node.type === "state") {
          const s = String(node.label || "");
          if (s === "초안") return "#94a3b8";
          if (s === "정리중") return "#fde047";
          if (s === "확정") return "#34d399";
          return "#cbd5e1";
        }
        if (node.type === "time") return "#cbd5e1";
        if (node.type === "category") {
          switch (node.label) {
            case "초법":
              return "#a78bfa";
            case "기술":
              return "#60a5fa";
            case "군사":
              return "#34d399";
            case "세력":
              return "#fb7185";
            case "인물":
              return "#fbbf24";
            case "장소/지역":
              return "#f59e0b";
            case "역사/사건":
              return "#f97316";
            case "용어/개념":
              return "#94a3b8";
            case "유물/아이템":
              return "#ec4899";
            case "플롯/에피소드":
              return "#fde047";
            case "시스템(게임)":
              return "#22c55e";
            case "메타":
              return "#cbd5e1";
            case "설정":
              return "#a3a3a3";
            default:
              return "#93c5fd";
          }
        }
        const primaryDomain = (node.domains && node.domains[0]) || node.domain || null;
        if (primaryDomain === "세계관") return "rgba(96, 165, 250, 0.9)";
        if (primaryDomain === "소설") return "rgba(244, 114, 182, 0.9)";
        if (primaryDomain === "게임") return "rgba(52, 211, 153, 0.9)";
        return "#9ca3af";
      }

      function upsertCachedNode(raw) {
        const id = String(raw.id);
        let node = nodeCache.get(id);
        if (!node) {
          node = { ...raw };
          nodeCache.set(id, node);
        } else {
          Object.assign(node, raw);
        }
        return node;
      }

      function renderCategories(raw) {
        const current = elCategory.value;
        const set = new Set();
        for (const n of raw.nodes || []) {
          if (n.type === "category") set.add(n.label);
        }
        const cats = Array.from(set).sort((a, b) => String(a).localeCompare(String(b), "ko"));

        elCategory.innerHTML = "";
        const optAll = document.createElement("option");
        optAll.value = "ALL";
        optAll.textContent = "전체";
        elCategory.appendChild(optAll);
        for (const c of cats) {
          const opt = document.createElement("option");
          opt.value = c;
          opt.textContent = c;
          elCategory.appendChild(opt);
        }
        elCategory.value = cats.includes(current) ? current : "ALL";
      }

      function computeTerritoryGraphData() {
        const raw = state.raw;
        if (!raw) return null;

        const q = state.query.trim();
        const visibleNodeIds = new Set();

        const expandedDomain = state.expandedCategoryScope ? state.expandedCategoryScope.domain : null;
        const expandedCategory = state.expandedCategoryScope ? state.expandedCategoryScope.category : null;

        const shouldShowItems =
          state.showItems &&
          (q.length > 0 ||
            state.domainFilter !== "ALL" ||
            state.categoryFilter !== "ALL" ||
            expandedDomain !== null);

        const baseNodes = [];
        const candidateItems = [];

        for (const n of raw.nodes || []) {
          if (n.type === "root" || n.type === "domain") {
            visibleNodeIds.add(n.id);
            baseNodes.push(upsertCachedNode(n));
            continue;
          }

          if (n.type === "category") {
            const domainOk = state.domainFilter === "ALL" || n.domain === state.domainFilter;
            const categoryOk = state.categoryFilter === "ALL" || n.label === state.categoryFilter;
            if (!domainOk || !categoryOk) continue;
            visibleNodeIds.add(n.id);
            baseNodes.push(upsertCachedNode(n));
            continue;
          }

          if (n.type !== "item") continue;
          if (!shouldShowItems) continue;

          const domains = Array.isArray(n.domains) ? n.domains : [];
          const domainOk = state.domainFilter === "ALL" || domains.includes(state.domainFilter);
          const categoryOk = state.categoryFilter === "ALL" || n.category === state.categoryFilter;
          const queryOk = q.length === 0 || includesCI(n.label, q);
          const expandedOk = expandedDomain ? domains.includes(expandedDomain) && n.category === expandedCategory : true;
          if (!domainOk || !categoryOk || !queryOk || !expandedOk) continue;

          candidateItems.push(upsertCachedNode(n));
        }

        candidateItems.sort((a, b) => String(a.label || "").localeCompare(String(b.label || ""), "ko"));

        if (state.selectedNodeId) {
          const idx = candidateItems.findIndex((n) => String(n.id) === String(state.selectedNodeId));
          if (idx >= 0) {
            const keep = candidateItems.splice(idx, 1)[0];
            candidateItems.unshift(keep);
          }
        }

        const truncated = candidateItems.length > state.itemLimit;
        const shownItems = truncated ? candidateItems.slice(0, state.itemLimit) : candidateItems;
        for (const n of shownItems) visibleNodeIds.add(n.id);

        const relationFocusId = state.showRelations ? state.selectedNodeId : null;
        const links = (raw.links || []).filter((l) => {
          const s = String(l.source);
          const t = String(l.target);
          if (!visibleNodeIds.has(s) || !visibleNodeIds.has(t)) return false;
          if (l.type === "relation") {
            if (!relationFocusId) return false;
            return s === relationFocusId || t === relationFocusId;
          }
          return true;
        });

        return {
          nodes: baseNodes.concat(shownItems),
          links,
          stats: { matchedItems: candidateItems.length, shownItems: shownItems.length, truncated },
        };
      }

      function computeLayerGraphData() {
        const raw = state.raw;
        if (!raw) return null;

        const q = state.query.trim();
        const items = (raw.nodes || []).filter((n) => n.type === "item");

        const candidate = [];
        for (const n of items) {
          const domains = Array.isArray(n.domains) ? n.domains : [];
          const domainOk = state.domainFilter === "ALL" || domains.includes(state.domainFilter);
          const categoryOk = state.categoryFilter === "ALL" || n.category === state.categoryFilter;
          const layer = inferLayerFromItem(n);
          const layerOk = state.layerFilter === "ALL" || layer === state.layerFilter;
          const queryOk = q.length === 0 || includesCI(n.label, q);
          if (!domainOk || !categoryOk || !layerOk || !queryOk) continue;
          candidate.push(upsertCachedNode({ ...n, layer }));
        }

        candidate.sort((a, b) => String(a.label || "").localeCompare(String(b.label || ""), "ko"));
        if (state.selectedNodeId) {
          const idx = candidate.findIndex((n) => String(n.id) === String(state.selectedNodeId));
          if (idx >= 0) {
            const keep = candidate.splice(idx, 1)[0];
            candidate.unshift(keep);
          }
        }

        const shouldShowItems = Boolean(state.showItems);
        const truncated = candidate.length > state.itemLimit;
        const shownItems = shouldShowItems ? (truncated ? candidate.slice(0, state.itemLimit) : candidate) : [];

        const nodes = [];
        const links = [];

        nodes.push(getRootNode(raw));

        const layerNodeId = new Map();
        for (const l of LAYERS) {
          const id = makeId("__layer", l);
          layerNodeId.set(l, id);
          nodes.push(upsertCachedNode({ id, type: "layer", label: LAYER_LABEL[l] || l, layer: l }));
          links.push({ source: getRootNode(raw).id, target: id, type: "hierarchy" });
        }

        const catNodeId = new Map();
        const ensureCat = (layer, category) => {
          const key = layer + "::" + category;
          let id = catNodeId.get(key);
          if (id) return id;
          id = makeId("__layercat", layer, category);
          catNodeId.set(key, id);
          nodes.push(upsertCachedNode({ id, type: "category", label: category, layer }));
          links.push({ source: layerNodeId.get(layer), target: id, type: "hierarchy" });
          return id;
        };

        for (const item of shownItems) {
          const layer = inferLayerFromItem(item);
          const cat = String(item.category || "기타");
          const catId = ensureCat(layer, cat);
          nodes.push(item);
          links.push({ source: catId, target: item.id, type: "hierarchy" });
        }

        return {
          nodes,
          links,
          stats: { matchedItems: candidate.length, shownItems: shownItems.length, truncated },
        };
      }

      function computePovGraphData() {
        const raw = state.raw;
        if (!raw) return null;

        const q = state.query.trim();
        const items = (raw.nodes || []).filter((n) => n.type === "item");

        const povFilter = state.povFilter;
        const showAll = povFilter === "ALL";
        const povs = showAll ? PERSPECTIVES.slice() : [povFilter];

        const candidate = [];
        for (const n of items) {
          const domains = Array.isArray(n.domains) ? n.domains : [];
          const domainOk = state.domainFilter === "ALL" || domains.includes(state.domainFilter);
          const categoryOk = state.categoryFilter === "ALL" || n.category === state.categoryFilter;
          const layer = inferLayerFromItem(n);
          const layerOk = state.layerFilter === "ALL" || layer === state.layerFilter;
          const queryOk = q.length === 0 || includesCI(n.label, q);
          if (!domainOk || !categoryOk || !layerOk || !queryOk) continue;

          if (!state.showItems) continue;

          if (!showAll) {
            if (!isVisibleToPerspective(n, povFilter)) continue;
            candidate.push(upsertCachedNode({ ...n, layer, pov: povFilter }));
            continue;
          }

          const assigned = pickPrimaryVisibility(n) || (layer === "PLAYER" ? "PLAYER" : layer === "NARRATIVE" ? "NPC" : layer === "SYSTEM" ? "종언자" : "CORE");
          candidate.push(upsertCachedNode({ ...n, layer, pov: assigned }));
        }

        candidate.sort((a, b) => String(a.label || "").localeCompare(String(b.label || ""), "ko"));
        if (state.selectedNodeId) {
          const idx = candidate.findIndex((n) => String(n.id) === String(state.selectedNodeId));
          if (idx >= 0) {
            const keep = candidate.splice(idx, 1)[0];
            candidate.unshift(keep);
          }
        }

        const truncated = candidate.length > state.itemLimit;
        const shownItems = truncated ? candidate.slice(0, state.itemLimit) : candidate;

        const nodes = [];
        const links = [];

        const root = getRootNode(raw);
        nodes.push(root);

        const povNodeId = new Map();
        for (const p of povs) {
          const id = makeId("__pov", p);
          povNodeId.set(p, id);
          nodes.push(upsertCachedNode({ id, type: "pov", label: p, pov: p }));
          links.push({ source: root.id, target: id, type: "hierarchy" });
        }

        for (const item of shownItems) {
          const p = showAll ? item.pov : povFilter;
          const id = povNodeId.get(p) || povNodeId.get(povFilter);
          if (!id) continue;
          nodes.push(item);
          links.push({ source: id, target: item.id, type: "hierarchy" });
        }

        return {
          nodes,
          links,
          stats: { matchedItems: candidate.length, shownItems: shownItems.length, truncated },
        };
      }

      function computeStateGraphData() {
        const raw = state.raw;
        if (!raw) return null;

        const q = state.query.trim();
        const items = (raw.nodes || []).filter((n) => n.type === "item");

        const STATUS_NODES = ["초안", "정리중", "확정", "미지정"];

        const candidate = [];
        for (const n of items) {
          const domains = Array.isArray(n.domains) ? n.domains : [];
          const domainOk = state.domainFilter === "ALL" || domains.includes(state.domainFilter);
          const categoryOk = state.categoryFilter === "ALL" || n.category === state.categoryFilter;
          const layer = inferLayerFromItem(n);
          const layerOk = state.layerFilter === "ALL" || layer === state.layerFilter;
          const queryOk = q.length === 0 || includesCI(n.label, q);
          if (!domainOk || !categoryOk || !layerOk || !queryOk) continue;

          if (!state.showItems) continue;

          const status = n.status ? String(n.status) : "미지정";
          const statusOk = state.statusFilter === "ALL" || status === state.statusFilter;
          if (!statusOk) continue;

          candidate.push(upsertCachedNode({ ...n, layer, status }));
        }

        candidate.sort((a, b) => String(a.label || "").localeCompare(String(b.label || ""), "ko"));
        if (state.selectedNodeId) {
          const idx = candidate.findIndex((n) => String(n.id) === String(state.selectedNodeId));
          if (idx >= 0) {
            const keep = candidate.splice(idx, 1)[0];
            candidate.unshift(keep);
          }
        }

        const truncated = candidate.length > state.itemLimit;
        const shownItems = truncated ? candidate.slice(0, state.itemLimit) : candidate;

        const nodes = [];
        const links = [];

        const root = getRootNode(raw);
        nodes.push(root);

        const statusNodeId = new Map();
        for (const s of STATUS_NODES) {
          const id = makeId("__state", s);
          statusNodeId.set(s, id);
          nodes.push(upsertCachedNode({ id, type: "state", label: s }));
          links.push({ source: root.id, target: id, type: "hierarchy" });
        }

        links.push({ source: statusNodeId.get("초안"), target: statusNodeId.get("정리중"), type: "transition" });
        links.push({ source: statusNodeId.get("정리중"), target: statusNodeId.get("확정"), type: "transition" });

        for (const item of shownItems) {
          const sid = statusNodeId.get(item.status || "미지정") || statusNodeId.get("미지정");
          nodes.push(item);
          links.push({ source: sid, target: item.id, type: "hierarchy" });
        }

        return {
          nodes,
          links,
          stats: { matchedItems: candidate.length, shownItems: shownItems.length, truncated },
        };
      }

      function getTimelineBucket(item) {
        const t = item && item.time ? String(item.time) : "";
        if (t) {
          const d = new Date(t);
          if (!Number.isNaN(d.getTime())) {
            const y = d.getUTCFullYear();
            return { key: "Y:" + y, label: String(y), sortKey: y };
          }
        }
        const label = item && item.timeLabel ? String(item.timeLabel).trim() : "";
        if (label) return { key: "L:" + label, label, sortKey: Number.POSITIVE_INFINITY };
        return { key: "UNSPEC", label: "미지정", sortKey: Number.POSITIVE_INFINITY + 1 };
      }

      function computeTimelineGraphData() {
        const raw = state.raw;
        if (!raw) return null;

        const q = state.query.trim();
        const items = (raw.nodes || []).filter((n) => n.type === "item");

        const matched = [];
        for (const n of items) {
          const domains = Array.isArray(n.domains) ? n.domains : [];
          const domainOk = state.domainFilter === "ALL" || domains.includes(state.domainFilter);
          const categoryOk = state.categoryFilter === "ALL" || n.category === state.categoryFilter;
          const layer = inferLayerFromItem(n);
          const layerOk = state.layerFilter === "ALL" || layer === state.layerFilter;
          const queryOk = q.length === 0 || includesCI(n.label, q);
          if (!domainOk || !categoryOk || !layerOk || !queryOk) continue;

          matched.push(upsertCachedNode({ ...n, layer }));
        }

        matched.sort((a, b) => String(a.label || "").localeCompare(String(b.label || ""), "ko"));
        if (state.selectedNodeId) {
          const idx = matched.findIndex((n) => String(n.id) === String(state.selectedNodeId));
          if (idx >= 0) {
            const keep = matched.splice(idx, 1)[0];
            matched.unshift(keep);
          }
        }

        const shouldShowItems = Boolean(state.showItems);
        const truncated = matched.length > state.itemLimit;
        const shownItems = shouldShowItems ? (truncated ? matched.slice(0, state.itemLimit) : matched) : [];

        const nodes = [];
        const links = [];

        const root = getRootNode(raw);
        nodes.push(root);

        const bucketCount = new Map();
        const bucketInfoByKey = new Map();
        for (const item of matched) {
          const b = getTimelineBucket(item);
          bucketInfoByKey.set(b.key, b);
          bucketCount.set(b.key, (bucketCount.get(b.key) || 0) + 1);
        }

        let buckets = [...bucketInfoByKey.values()].sort((a, b) => {
          if (a.sortKey !== b.sortKey) return a.sortKey - b.sortKey;
          return String(a.label).localeCompare(String(b.label), "ko");
        });

        const MAX_BUCKETS = 80;
        const OTHER_KEY = "__OTHER__";
        if (buckets.length > MAX_BUCKETS) {
          const kept = buckets.slice(0, MAX_BUCKETS - 1);
          kept.push({ key: OTHER_KEY, label: "(기타…)", sortKey: Number.POSITIVE_INFINITY + 9 });
          buckets = kept;
        }

        const bucketNodeId = new Map();
        for (const b of buckets) {
          const id = makeId("__time", b.key);
          bucketNodeId.set(b.key, id);
          nodes.push(upsertCachedNode({ id, type: "time", label: b.label }));
          links.push({ source: root.id, target: id, type: "hierarchy" });
        }

        for (const item of shownItems) {
          const b = getTimelineBucket(item);
          const bid = bucketNodeId.get(b.key) || bucketNodeId.get(OTHER_KEY);
          if (!bid) continue;
          nodes.push(item);
          links.push({ source: bid, target: item.id, type: "hierarchy" });
        }

        return {
          nodes,
          links,
          stats: { matchedItems: matched.length, shownItems: shownItems.length, truncated },
        };
      }

      function computeGraphData() {
        if (state.mode === "territory") return computeTerritoryGraphData();
        if (state.mode === "layer") return computeLayerGraphData();
        if (state.mode === "pov") return computePovGraphData();
        if (state.mode === "state") return computeStateGraphData();
        if (state.mode === "timeline") return computeTimelineGraphData();
        return null;
      }

      function computeById(graphData) {
        const m = new Map();
        for (const n of graphData.nodes || []) m.set(String(n.id), n);
        return m;
      }

      function computeHighlight(graphData) {
        const focusId = state.hoveredNodeId || state.selectedNodeId;
        const highlightNodes = new Set();
        const highlightLinks = new Set();
        if (!graphData || !focusId) return { highlightNodes, highlightLinks };

        highlightNodes.add(String(focusId));
        for (const l of graphData.links || []) {
          const s = getEndpointId(l.source);
          const t = getEndpointId(l.target);
          if (!s || !t) continue;
          if (s !== String(focusId) && t !== String(focusId)) continue;
          highlightNodes.add(s);
          highlightNodes.add(t);
          highlightLinks.add(linkKey(s, t, l.type));
        }
        return { highlightNodes, highlightLinks };
      }

      function openNotion(node) {
        if (!node || !node.url) return;
        window.open(node.url, "_blank", "noopener,noreferrer");
      }

      function updateSelectedUI(node) {
        if (!node) {
          elSelectedEmpty.style.display = "";
          elSelectedBox.style.display = "none";
          elSelectedBox.innerHTML = "";
          return;
        }

        elSelectedEmpty.style.display = "none";
        elSelectedBox.style.display = "";

        const badges = [];
        badges.push('<span class="badge">' + node.type + "</span>");
        if (node.domain) badges.push('<span class="badge">domain: ' + node.domain + "</span>");
        if (node.domains && node.domains.length)
          badges.push('<span class="badge">domains: ' + node.domains.join(", ") + "</span>");
        if (node.category) badges.push('<span class="badge">cat: ' + node.category + "</span>");
        if (node.layer) {
          const l = normalizeLayer(node.layer) || inferLayerFromItem(node);
          badges.push('<span class="badge">layer: ' + (l === "UNSORTED" ? "미분류" : l) + "</span>");
        }
        if (node.pov) badges.push('<span class="badge">POV: ' + node.pov + "</span>");
        if (node.time || node.timeLabel) badges.push('<span class="badge">time: ' + (node.timeLabel || node.time) + "</span>");
        if (node.status) badges.push('<span class="badge">상태: ' + node.status + "</span>");

        const tags =
          node.tags && node.tags.length
            ? '<div style="margin-top:10px; font-size:12px; color:#cbd5e1; line-height:1.4;"><div style="color: var(--muted);">연관</div><div>' +
              node.tags.join(", ") +
              "</div></div>"
            : "";

        elSelectedBox.innerHTML =
          '<div style="font-size:14px; font-weight:900; line-height:1.25;">' +
          (node.label || "") +
          "</div>" +
          '<div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">' +
          badges.join("") +
          "</div>" +
          tags +
          '<div style="display:flex; gap:8px; margin-top:12px;">' +
          '<button id="btn-open-notion" type="button" style="' +
          (node.url ? "" : "display:none;") +
          '">노션 열기</button>' +
          "</div>";

        const btn = document.getElementById("btn-open-notion");
        if (btn) btn.addEventListener("click", () => openNotion(node));
      }

      function renderItemList(graphData, byId) {
        if (!state.showItems || !graphData) {
          elItemListBox.style.display = "none";
          elItemList.innerHTML = "";
          return;
        }

        const items = (graphData.nodes || []).filter((n) => n.type === "item");
        if (items.length === 0) {
          elItemListBox.style.display = "none";
          elItemList.innerHTML = "";
          return;
        }

        elItemListBox.style.display = "";
        elItemListCount.textContent = Math.min(ITEM_LIST_LIMIT, items.length) + "/" + items.length;
        elItemListHint.style.display = "none";
        elItemList.innerHTML = "";

        const shown = items.slice(0, ITEM_LIST_LIMIT);
        for (const n of shown) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = String(n.id) === String(state.selectedNodeId) ? "selected" : "";
          const layer = n.layer ? normalizeLayer(n.layer) || inferLayerFromItem(n) : null;
          const right = [];
          if (layer && layer !== "UNSORTED") right.push(layer);
          if (n.status) right.push(n.status);
          btn.innerHTML =
            '<div style="display:flex; align-items:baseline; justify-content:space-between; gap:10px;">' +
            '<div style="font-size:12px; font-weight:800; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">' +
            (n.label || "") +
            "</div>" +
            (right.length
              ? '<div style="font-size:11px; color: var(--muted); white-space:nowrap;">' + right.join(" · ") + "</div>"
              : "") +
            "</div>";
          btn.addEventListener("click", () => {
            state.userInteracted = true;
            state.selectedNodeId = String(n.id);
            state.hoveredNodeId = null;
            const hit = byId.get(String(n.id));
            if (hit) focusNode(hit);
            refresh();
          });
          elItemList.appendChild(btn);
        }

        if (items.length > ITEM_LIST_LIMIT) {
          elItemListHint.textContent = "너무 많아서 " + ITEM_LIST_LIMIT + "개까지만 목록에 표시합니다. (검색/필터로 줄이기)";
          elItemListHint.style.display = "";
        }
      }

      function focusNode(node) {
        if (!node || typeof node.x !== "number" || typeof node.y !== "number") return;
        graph.centerAt(node.x, node.y, 450);
        const currentZoom = graph.zoom() || 1;
        if (currentZoom < 1.8) graph.zoom(2.6, 450);
      }

      function updateUiFromGraphData(graphData, byId) {
        if (!state.raw) return;

        const meta = state.raw.meta || {};
        const exportedAt = meta.exportedAt || "";
        if (exportedAt) {
          elExport.textContent = "export: " + exportedAt;
          elExport.style.display = "";
        } else {
          elExport.style.display = "none";
        }

        const nodeCount = (state.raw.nodes || []).length;
        const linkCount = (state.raw.links || []).length;
        const pageCount = meta.totalPagesFetched != null ? meta.totalPagesFetched : "?";
        const modeLabel = (MODES.find((m) => m.id === state.mode) || {}).label || state.mode;
        const viewNodeCount = (graphData.nodes || []).length;
        const viewLinkCount = (graphData.links || []).length;
        elStats.textContent =
          "모드: " +
          modeLabel +
          " | pages: " +
          pageCount +
          " | view nodes: " +
          viewNodeCount +
          " / view links: " +
          viewLinkCount +
          " | raw nodes: " +
          nodeCount +
          " / raw links: " +
          linkCount;

        if (state.showItems) {
          elItemControls.style.display = "";
          const showStatExtra =
            state.mode === "territory" ? graphData.stats && (graphData.stats.matchedItems > 0 || state.expandedCategoryScope) : graphData.stats && graphData.stats.matchedItems > 0;
          elItemStats.style.display = showStatExtra ? "" : "none";
          if (graphData.stats) {
            let t = "항목: " + graphData.stats.shownItems + "/" + graphData.stats.matchedItems;
            if (graphData.stats.truncated) t += " (최대 " + state.itemLimit + "개만 표시)";
            if (state.mode === "territory" && state.expandedCategoryScope)
              t += "\\n펼침: " + state.expandedCategoryScope.domain + " / " + state.expandedCategoryScope.category;
            elItemStats.textContent = t;
          }
        } else {
          elItemControls.style.display = "none";
          elItemStats.style.display = "none";
          state.expandedCategoryScope = null;
        }

        elBtnCollapse.style.display = state.expandedCategoryScope ? "" : "none";

        const selected = state.selectedNodeId ? byId.get(String(state.selectedNodeId)) : null;
        updateSelectedUI(selected);
      }

      function updateModeUI() {
        const mode = state.mode;

        for (const btn of elModeTabs.querySelectorAll("button[data-mode]")) {
          btn.classList.toggle("active", btn.dataset.mode === mode);
        }

        elModeHint.textContent = MODE_HINTS[mode] || "";

        elControlLayer.style.display = mode === "layer" || mode === "ui" ? "" : "none";
        elControlPov.style.display = mode === "pov" ? "" : "none";
        elControlStatus.style.display = mode === "state" || mode === "ui" ? "" : "none";

        const allowMindmap = mode === "territory";
        elMindmap.disabled = !allowMindmap;
        if (elMindmap.parentElement) elMindmap.parentElement.style.opacity = allowMindmap ? "1" : "0.45";

        const allowRelations = mode === "territory";
        elShowRelations.disabled = !allowRelations;
        if (elShowRelations.parentElement) elShowRelations.parentElement.style.opacity = allowRelations ? "1" : "0.45";

        const allowShowItems = mode !== "ui";
        elShowItems.disabled = !allowShowItems;
        if (elShowItems.parentElement) elShowItems.parentElement.style.opacity = allowShowItems ? "1" : "0.45";
      }

      function setMode(nextMode) {
        const next = String(nextMode || "").trim();
        if (!next) return;
        state.mode = next;
        state.userInteracted = false;
        state.autoFitDone = false;
        state.hoveredNodeId = null;
        state.selectedNodeId = null;
        state.expandedCategoryScope = null;
        updateModeUI();
        refresh();
      }

      function getDagModeForMode() {
        if (state.mode === "territory") return state.mindmapLayout ? "radialout" : null;
        if (state.mode === "layer") return "td";
        if (state.mode === "pov") return "radialout";
        if (state.mode === "state") return "lr";
        if (state.mode === "timeline") return "lr";
        return null;
      }

      function getDagLevelDistanceForMode() {
        if (state.mode === "territory") return state.mindmapLayout ? 110 : null;
        if (state.mode === "layer") return 130;
        if (state.mode === "pov") return 120;
        if (state.mode === "state") return 140;
        if (state.mode === "timeline") return 140;
        return null;
      }

      function renderDashboard() {
        const raw = state.raw;
        if (!raw) return;

        const items = (raw.nodes || []).filter((n) => n.type === "item");
        const meta = raw.meta || {};
        const exportedAt = meta.exportedAt || "";

        const countDomain = new Map([
          ["세계관", 0],
          ["소설", 0],
          ["게임", 0],
        ]);
        const countLayer = new Map(
          LAYERS.map((l) => [l, 0]),
        );
        const countStatus = new Map([
          ["초안", 0],
          ["정리중", 0],
          ["확정", 0],
          ["미지정", 0],
        ]);

        for (const it of items) {
          const domains = Array.isArray(it.domains) ? it.domains : [];
          for (const d of domains) countDomain.set(d, (countDomain.get(d) || 0) + 1);
          const layer = inferLayerFromItem(it);
          countLayer.set(layer, (countLayer.get(layer) || 0) + 1);
          const status = it.status ? String(it.status) : "미지정";
          countStatus.set(status, (countStatus.get(status) || 0) + 1);
        }

        const filtersActive =
          state.query.trim().length > 0 ||
          state.domainFilter !== "ALL" ||
          state.categoryFilter !== "ALL" ||
          state.layerFilter !== "ALL" ||
          state.statusFilter !== "ALL";

        const filtered = items.filter((it) => {
          const domains = Array.isArray(it.domains) ? it.domains : [];
          if (state.domainFilter !== "ALL" && !domains.includes(state.domainFilter)) return false;
          if (state.categoryFilter !== "ALL" && it.category !== state.categoryFilter) return false;
          const layer = inferLayerFromItem(it);
          if (state.layerFilter !== "ALL" && layer !== state.layerFilter) return false;
          const status = it.status ? String(it.status) : "미지정";
          if (state.statusFilter !== "ALL" && status !== state.statusFilter) return false;
          if (state.query.trim().length > 0 && !includesCI(it.label, state.query.trim())) return false;
          return true;
        });

        filtered.sort((a, b) => String(a.label || "").localeCompare(String(b.label || ""), "ko"));
        const truncated = filtered.length > state.itemLimit;
        const shown = filtersActive ? (truncated ? filtered.slice(0, state.itemLimit) : filtered) : [];

        elAltView.innerHTML =
          '<div style="max-width: 980px; margin: 0 auto;">' +
          '<div style="font-size: 16px; font-weight: 950;">UI 대시보드</div>' +
          '<div class="mini" style="margin-top: 6px;">export: ' +
          (exportedAt || "-") +
          " | 총 항목: " +
          items.length +
          "</div>" +
          '<div style="margin-top: 14px;" class="cardGrid">' +
          ['세계관', '소설', '게임']
            .map((d) => {
              const v = countDomain.get(d) || 0;
              return (
                '<button class="card" type="button" data-set-domain="' +
                d +
                '">' +
                '<div class="cardTitle">도메인</div>' +
                '<div class="cardValue" style="color:' +
                (d === "세계관" ? "#60a5fa" : d === "소설" ? "#f472b6" : "#34d399") +
                ';">' +
                d +
                "</div>" +
                '<div class="mini">항목: ' +
                v +
                "</div>" +
                "</button>"
              );
            })
            .join("") +
          "</div>" +
          '<div style="margin-top: 14px;" class="cardGrid">' +
          ["CORE", "SYSTEM", "NARRATIVE", "PLAYER"]
            .map((l) => {
              const v = countLayer.get(l) || 0;
              return (
                '<button class="card" type="button" data-set-layer="' +
                l +
                '">' +
                '<div class="cardTitle">레이어</div>' +
                '<div class="cardValue">' +
                l +
                "</div>" +
                '<div class="mini">항목: ' +
                v +
                "</div>" +
                "</button>"
              );
            })
            .join("") +
          "</div>" +
          '<div style="margin-top: 14px;" class="cardGrid">' +
          ["초안", "정리중", "확정", "미지정"]
            .map((s) => {
              const v = countStatus.get(s) || 0;
              return (
                '<button class="card" type="button" data-set-status="' +
                s +
                '">' +
                '<div class="cardTitle">상태</div>' +
                '<div class="cardValue">' +
                s +
                "</div>" +
                '<div class="mini">항목: ' +
                v +
                "</div>" +
                "</button>"
              );
            })
            .join("") +
          "</div>" +
          '<div class="row" style="margin-top: 14px; gap: 10px; flex-wrap: wrap;">' +
          '<button type="button" data-action="clear">필터 초기화</button>' +
          '<button type="button" data-action="toTerritory">그래프(영역)로 보기</button>' +
          "</div>" +
          '<div class="hint" style="margin-top: 10px;">' +
          (filtersActive
            ? "결과: " +
              shown.length +
              "/" +
              filtered.length +
              (truncated ? " (최대 " + state.itemLimit + "개만 표시)" : "")
            : "검색/필터를 하나라도 걸면 결과 목록을 보여줍니다.") +
          "</div>" +
          '<div class="list" style="margin-top: 10px; max-height: none;">' +
          (filtersActive
            ? shown
                .map((it) => {
                  const status = it.status ? String(it.status) : "";
                  const layer = inferLayerFromItem(it);
                  return (
                    '<button type="button" data-open-url="' +
                    (it.url || "") +
                    '">' +
                    '<div style="display:flex; align-items:baseline; justify-content:space-between; gap:10px;">' +
                    '<div style="font-size:12px; font-weight:800; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">' +
                    (it.label || "") +
                    "</div>" +
                    '<div style="font-size:11px; color: var(--muted); white-space:nowrap;">' +
                    (layer !== "UNSORTED" ? layer : "") +
                    (status ? " · " + status : "") +
                    "</div>" +
                    "</div>" +
                    "</button>"
                  );
                })
                .join("")
            : "") +
          "</div>" +
          "</div>";
      }

      function refresh() {
        if (!state.raw) return;

        if (state.mode === "ui") {
          elGraph.style.display = "none";
          elAltView.style.display = "";
          renderDashboard();
          elItemListBox.style.display = "none";
          elSelectedBox.style.display = "none";
          elSelectedEmpty.style.display = "";
          elSelectedEmpty.textContent = "UI 모드: 오른쪽 목록에서 선택하세요.";
          elItemControls.style.display = "none";
          elItemStats.style.display = "none";
          elBtnCollapse.style.display = "none";
          return;
        }

        elGraph.style.display = "";
        elAltView.style.display = "none";

        // Expand scope hygiene (영역 모드 전용)
        if (state.mode !== "territory") {
          state.expandedCategoryScope = null;
        } else {
          const q = state.query.trim();
          if (!state.showItems) state.expandedCategoryScope = null;
          if (state.showItems && (q.length > 0 || state.domainFilter !== "ALL" || state.categoryFilter !== "ALL")) {
            state.expandedCategoryScope = null;
          }
        }

        const graphData = computeGraphData();
        if (!graphData) return;
        const byId = computeById(graphData);

        if (state.selectedNodeId && !byId.has(String(state.selectedNodeId))) state.selectedNodeId = null;
        if (state.hoveredNodeId && !byId.has(String(state.hoveredNodeId))) state.hoveredNodeId = null;

        const highlight = computeHighlight(graphData);

        graph
          .graphData(graphData)
          .dagMode(getDagModeForMode())
          .dagLevelDistance(getDagLevelDistanceForMode())
          .nodeVal((n) => getNodeSize(n))
          .nodeColor((n) => {
            const base = getNodeBaseColor(n);
            if (highlight.highlightNodes.size === 0) return base;
            if (highlight.highlightNodes.has(String(n.id))) return base;
            return "rgba(148, 163, 184, 0.55)";
          })
          .linkWidth((l) => {
            const s = getEndpointId(l.source);
            const t = getEndpointId(l.target);
            if (!s || !t) return 0.8;
            const key = linkKey(s, t, l.type);
            const base = l.type === "transition" ? 1.6 : 0.9;
            return highlight.highlightLinks.has(key) ? 2.2 : base;
          })
          .linkColor((l) => {
            if (l.type === "relation") return "rgba(248, 113, 113, 0.85)";
            if (l.type === "transition") return "rgba(56, 189, 248, 0.75)";
            const s = getEndpointId(l.source);
            const t = getEndpointId(l.target);
            if (!s || !t) return "rgba(148, 163, 184, 0.18)";
            const key = linkKey(s, t, l.type);
            if (highlight.highlightLinks.size === 0) return "rgba(148, 163, 184, 0.18)";
            return highlight.highlightLinks.has(key) ? "rgba(226, 232, 240, 0.5)" : "rgba(148, 163, 184, 0.08)";
          })
          .linkLineDash((l) => (l.type === "relation" ? [6, 4] : l.type === "transition" ? [3, 3] : null))
          .nodeCanvasObjectMode(() => "after")
          .nodeCanvasObject((node, ctx, globalScale) => {
            const label = node.label;
            if (!label) return;

            const alwaysLabel = node.type !== "item";
            const isFocus = String(node.id) === String(state.selectedNodeId) || String(node.id) === String(state.hoveredNodeId);
            const zoomedIn = globalScale > 2.2;
            if (!alwaysLabel && !isFocus && !zoomedIn) return;

            const fontSize = Math.max(10, 14 / globalScale);
            ctx.font = fontSize + "px sans-serif";
            const textWidth = ctx.measureText(label).width;
            const padding = 6 / globalScale;

            const x = node.x || 0;
            const y = node.y || 0;
            ctx.fillStyle = "rgba(2, 4, 9, 0.65)";
            ctx.fillRect(x - textWidth / 2 - padding, y + 7 / globalScale, textWidth + padding * 2, fontSize + padding);

            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillStyle = "#e2e8f0";
            ctx.fillText(label, x, y + 7 / globalScale);
          });

        updateUiFromGraphData(graphData, byId);
        renderItemList(graphData, byId);
      }

      function syncStateFromControls() {
        state.query = elQ.value || "";
        state.domainFilter = elDomain.value || "ALL";
        state.categoryFilter = elCategory.value || "ALL";
        state.layerFilter = elLayer ? elLayer.value || "ALL" : "ALL";
        state.povFilter = elPov ? elPov.value || "PLAYER" : "PLAYER";
        state.statusFilter = elStatus ? elStatus.value || "ALL" : "ALL";
        state.showItems = Boolean(elShowItems.checked);
        state.showRelations = Boolean(elShowRelations.checked);
        state.mindmapLayout = Boolean(elMindmap.checked);
        state.itemLimit = Number(elItemLimit.value || 250);
      }

      function resizeGraph() {
        const rect = elGraph.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        graph.width(Math.floor(rect.width));
        graph.height(Math.floor(rect.height));
      }

      async function loadRawGraph() {
        const res = await fetch("./terminus-graph.json", { cache: "no-store" });
        if (!res.ok) throw new Error("terminus-graph.json 로드 실패: HTTP " + res.status);
        return res.json();
      }

      async function doExportReload() {
        try {
          state.raw = await loadRawGraph();
          renderCategories(state.raw);
          updateModeUI();
          state.autoFitDone = false;
          refresh();
        } catch (e) {
          elStats.textContent = String((e && e.message) || e);
        }
      }

      // Init graph
      const graph = ForceGraph()(elGraph)
        .backgroundColor("rgba(2, 4, 9, 0)")
        .nodeId("id")
        .linkSource("source")
        .linkTarget("target")
        .warmupTicks(DEFAULT_WARMUP_TICKS)
        .cooldownTicks(DEFAULT_COOLDOWN_TICKS)
        .d3VelocityDecay(0.55)
        .onNodeHover((node) => {
          state.hoveredNodeId = node && node.id != null ? String(node.id) : null;
          refresh();
        })
        .onNodeClick((node) => {
          if (!node || node.id == null) return;
          state.userInteracted = true;

          const id = String(node.id);
          state.selectedNodeId = id;

          if (
            state.mode === "territory" &&
            state.showItems &&
            state.domainFilter === "ALL" &&
            state.categoryFilter === "ALL" &&
            state.query.trim().length === 0 &&
            node.type === "category" &&
            node.domain
          ) {
            const next = { domain: node.domain, category: node.label };
            if (
              state.expandedCategoryScope &&
              state.expandedCategoryScope.domain === next.domain &&
              state.expandedCategoryScope.category === next.category
            ) {
              state.expandedCategoryScope = null;
            } else {
              state.expandedCategoryScope = next;
            }
          }

          focusNode(node);
          refresh();
        })
        .onBackgroundClick(() => {
          state.selectedNodeId = null;
          refresh();
        })
        .onEngineStop(() => {
          if (state.autoFitDone) return;
          if (state.userInteracted) return;
          graph.zoomToFit(450, 70);
          state.autoFitDone = true;
        });

      // mark interaction
      elGraph.addEventListener(
        "pointerdown",
        () => {
          state.userInteracted = true;
        },
        { passive: true },
      );

      // Wire controls
      elQ.addEventListener("input", () => {
        syncStateFromControls();
        refresh();
      });
      elDomain.addEventListener("change", () => {
        syncStateFromControls();
        refresh();
      });
      elCategory.addEventListener("change", () => {
        syncStateFromControls();
        refresh();
      });
      elShowItems.addEventListener("change", () => {
        syncStateFromControls();
        refresh();
      });
      elShowRelations.addEventListener("change", () => {
        syncStateFromControls();
        refresh();
      });
      elMindmap.addEventListener("change", () => {
        state.autoFitDone = false;
        syncStateFromControls();
        refresh();
      });
      elItemLimit.addEventListener("change", () => {
        syncStateFromControls();
        refresh();
      });
      if (elLayer) {
        elLayer.addEventListener("change", () => {
          syncStateFromControls();
          refresh();
        });
      }
      if (elPov) {
        elPov.addEventListener("change", () => {
          syncStateFromControls();
          refresh();
        });
      }
      if (elStatus) {
        elStatus.addEventListener("change", () => {
          syncStateFromControls();
          refresh();
        });
      }
      elBtnCollapse.addEventListener("click", () => {
        state.expandedCategoryScope = null;
        refresh();
      });

      // Mode tabs
      for (const btn of elModeTabs.querySelectorAll("button[data-mode]")) {
        btn.addEventListener("click", () => {
          setMode(btn.dataset.mode);
        });
      }

      // Dashboard actions (UI 모드)
      elAltView.addEventListener("click", (e) => {
        const btn = e.target && e.target.closest ? e.target.closest("button") : null;
        if (!btn) return;

        const openUrl = btn.dataset.openUrl;
        if (openUrl) {
          window.open(openUrl, "_blank", "noopener,noreferrer");
          return;
        }

        const setDomain = btn.dataset.setDomain;
        if (setDomain) {
          elDomain.value = setDomain;
          syncStateFromControls();
          refresh();
          return;
        }

        const setLayer = btn.dataset.setLayer;
        if (setLayer) {
          elLayer.value = setLayer;
          syncStateFromControls();
          refresh();
          return;
        }

        const setStatus = btn.dataset.setStatus;
        if (setStatus) {
          elStatus.value = setStatus;
          syncStateFromControls();
          refresh();
          return;
        }

        const action = btn.dataset.action;
        if (action === "clear") {
          elQ.value = "";
          elDomain.value = "ALL";
          elCategory.value = "ALL";
          if (elLayer) elLayer.value = "ALL";
          if (elPov) elPov.value = "PLAYER";
          if (elStatus) elStatus.value = "ALL";
          syncStateFromControls();
          refresh();
          return;
        }
        if (action === "toTerritory") {
          setMode("territory");
          return;
        }
      });

      document.getElementById("btn-fit").addEventListener("click", () => graph.zoomToFit(350, 50));
      document.getElementById("btn-export").addEventListener("click", () => doExportReload());

      window.addEventListener("resize", () => resizeGraph());

      // Boot
      syncStateFromControls();
      updateModeUI();
      resizeGraph();
      doExportReload();
    </script>
  </body>
</html>
